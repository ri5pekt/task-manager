### PROJECT SNAPSHOT
Generated: 2025-09-20 12:48:37 +03:00
Root: C:\Users\denis\Desktop\docker-projects\task-manager

--- PROJECT STRUCTURE (filtered) ---

[DIR] .
  - .env
  - .env.example
  - .gitignore
  - auth-testuser.ps1
  - cookies.txt
  - docker-compose.yml
  - project_snapshot_2025-09-19_20-33-31.txt
  - README.md
[DIR] db\migrations
  - 0001_users.down.sql
  - 0001_users.up.sql
  - 0002_boards_and_lists.down.sql
  - 0002_boards_and_lists.up.sql
  - 0003_tasks.down.sql
  - 0003_tasks.up.sql
  - 0004_task_creator_and_assignees.down.sql
  - 0004_task_creator_and_assignees.up.sql
  - 0005_comments.down.sql
  - 0005_comments.up.sql
  - 0006_workspaces.down.sql
  - 0006_workspaces.up.sql
[DIR] db\seed
  - seed.sql
[DIR] server
  - .air.toml
  - Dockerfile
  - go.mod
[DIR] server\cmd\api
  - handlers_auth.go
  - handlers_board.go
  - handlers_comments.go
  - handlers_lists.go
  - handlers_tasks.go
  - handlers_uploads.go
  - main.go
  - routes.go
[DIR] web
  - .env
  - .gitignore
  - Dockerfile
  - index.html
  - package.json
  - README.md
  - vite.config.js
[DIR] web\public
  - vite.svg
[DIR] web\src
  - App.vue
  - main.js
  - router.js
  - style.css
[DIR] web\src\assets
  - vue.svg
[DIR] web\src\components
  - HelloWorld.vue
  - RichEditor.vue
  - SafeHtml.vue
  - TaskModal.vue
[DIR] web\src\lib
  - api.js
[DIR] web\src\stores
  - auth.js
[DIR] web\src\views
  - Board.vue
  - Home.vue
  - Login.vue
  - Register.vue

--- FILE CONTENTS (filtered) ---


===== BEGIN FILE: .env =====

POSTGRES_USER=app
POSTGRES_PASSWORD=app
POSTGRES_DB=taskmgr
PGADMIN_DEFAULT_EMAIL=admin@example.com
PGADMIN_DEFAULT_PASSWORD=admin123
DB_DSN=postgres://app:app@db:5432/taskmgr?sslmode=disable

===== END FILE =====


===== BEGIN FILE: .env.example =====

POSTGRES_USER=app
POSTGRES_PASSWORD=app
POSTGRES_DB=taskmgr
PGADMIN_DEFAULT_EMAIL=admin@example.com
PGADMIN_DEFAULT_PASSWORD=admin123
DB_DSN=postgres://app:app@db:5432/taskmgr?sslmode=disable

===== END FILE =====


===== BEGIN FILE: .gitignore =====

# Node
node_modules/
web/node_modules/

# pnpm store (root + nested)
.pnpm-store/
web/.pnpm-store/
**/.pnpm-store/

# Build output
dist/

# Environment files
.env
.env.local
.env.*.local

# Editor/IDE settings
.vscode/
.idea/

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# OS junk
.DS_Store
Thumbs.db

uploads/



# pnpm store (root + nested)
.pnpm-store/
web/.pnpm-store/
**/.pnpm-store/

# VS Code anywhere
**/.vscode/


# dev artifacts
cookies.txt
server/uploads/
server/tmp/
web/.env
web/node_modules/
web/dist/

===== END FILE =====


===== BEGIN FILE: auth-testuser.ps1 =====

param(
  [string]$Email = "test@example.com",
  [string]$Password = "test123"
)

# Build login JSON
$login = @{ email=$Email; password=$Password } | ConvertTo-Json -Compress

# Save cookies
curl.exe -s -i -c cookies.txt -b cookies.txt `
  -X POST http://localhost:5173/api/login `
  -H "Content-Type: application/json" `
  --data-binary "$login" | Out-Null

# Verify
$me = curl.exe -s -b cookies.txt http://localhost:5173/api/me | ConvertFrom-Json
Write-Host "Logged in as $($me.name) <$($me.email)>, user_id=$($me.id)"


===== END FILE =====


===== BEGIN FILE: cookies.txt =====

# Netscape HTTP Cookie File
# https://curl.se/docs/http-cookies.html
# This file was generated by libcurl! Edit at your own risk.

localhost	FALSE	/	FALSE	0	csrf	gaegEn9GmjuBVtt8Fv48Ha3-e2l3cyD9
#HttpOnly_localhost	FALSE	/	FALSE	0	sid	qxCGf8dl61tONygpRIPsKLYTClHljduc


===== END FILE =====


===== BEGIN FILE: db\migrations\0001_users.down.sql =====

DROP TABLE IF EXISTS users;


===== END FILE =====


===== BEGIN FILE: db\migrations\0001_users.up.sql =====

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE IF NOT EXISTS users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  email TEXT NOT NULL UNIQUE,
  password_hash TEXT NOT NULL,
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);


===== END FILE =====


===== BEGIN FILE: db\migrations\0002_boards_and_lists.down.sql =====

DROP TABLE IF EXISTS lists;
DROP TABLE IF EXISTS boards;

===== END FILE =====


===== BEGIN FILE: db\migrations\0002_boards_and_lists.up.sql =====

-- Boards hold lists; simple for now (owner_id optional for later).
CREATE TABLE IF NOT EXISTS boards (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  owner_id UUID NULL REFERENCES users(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Lists (columns) belong to a board; position supports ordering left→right.
CREATE TABLE IF NOT EXISTS lists (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  board_id UUID NOT NULL REFERENCES boards(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  position INT NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Helpful indexes
CREATE INDEX IF NOT EXISTS idx_lists_board ON lists(board_id);
CREATE INDEX IF NOT EXISTS idx_lists_board_position ON lists(board_id, position);


===== END FILE =====


===== BEGIN FILE: db\migrations\0003_tasks.down.sql =====

DROP TABLE IF EXISTS tasks;

===== END FILE =====


===== BEGIN FILE: db\migrations\0003_tasks.up.sql =====

CREATE TABLE IF NOT EXISTS tasks (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  list_id UUID NOT NULL REFERENCES lists(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT NOT NULL DEFAULT '',
  position INT NOT NULL DEFAULT 0,                    -- order within a list (left→right top→bottom)
  status TEXT NOT NULL DEFAULT 'todo',                -- we'll normalize later if needed
  assignee_id UUID NULL REFERENCES users(id) ON DELETE SET NULL,
  due_date DATE NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- quick lookups & ordered pulls
CREATE INDEX IF NOT EXISTS idx_tasks_list ON tasks(list_id);
CREATE INDEX IF NOT EXISTS idx_tasks_list_position ON tasks(list_id, position);
CREATE INDEX IF NOT EXISTS idx_tasks_assignee ON tasks(assignee_id);


===== END FILE =====


===== BEGIN FILE: db\migrations\0004_task_creator_and_assignees.down.sql =====

DROP TABLE IF EXISTS task_assignees;
ALTER TABLE tasks DROP COLUMN IF EXISTS created_by;

===== END FILE =====


===== BEGIN FILE: db\migrations\0004_task_creator_and_assignees.up.sql =====

-- Add creator to tasks
ALTER TABLE tasks
  ADD COLUMN created_by UUID NULL REFERENCES users(id) ON DELETE SET NULL;

-- Many-to-many assignees
CREATE TABLE IF NOT EXISTS task_assignees (
  task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  assigned_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  PRIMARY KEY (task_id, user_id)
);

-- Helpful indexes (optional but nice)
CREATE INDEX IF NOT EXISTS idx_task_assignees_user ON task_assignees(user_id);


===== END FILE =====


===== BEGIN FILE: db\migrations\0005_comments.down.sql =====

DROP TABLE IF EXISTS comments;

===== END FILE =====


===== BEGIN FILE: db\migrations\0005_comments.up.sql =====

CREATE TABLE IF NOT EXISTS comments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  task_id   UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
  author_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  body TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_comments_task ON comments(task_id);


===== END FILE =====


===== BEGIN FILE: db\migrations\0006_workspaces.down.sql =====

ALTER TABLE boards DROP COLUMN IF EXISTS workspace_id;
DROP TABLE IF EXISTS workspace_members;
DROP TABLE IF EXISTS workspaces;


===== END FILE =====


===== BEGIN FILE: db\migrations\0006_workspaces.up.sql =====

CREATE TABLE IF NOT EXISTS workspaces (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  slug TEXT UNIQUE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS workspace_members (
  workspace_id UUID NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  role TEXT NOT NULL DEFAULT 'member',
  PRIMARY KEY (workspace_id, user_id)
);

ALTER TABLE boards
  ADD COLUMN workspace_id UUID NULL REFERENCES workspaces(id) ON DELETE CASCADE;

CREATE INDEX IF NOT EXISTS idx_boards_workspace ON boards(workspace_id);


===== END FILE =====


===== BEGIN FILE: db\seed\seed.sql =====

-- DEV-ONLY SEED. Run after `migrate up` on an empty DB.

-- 1) One demo user
INSERT INTO users (email, password_hash, name)
VALUES ('demo@example.com', 'x', 'Demo User')
ON CONFLICT (email) DO NOTHING;

-- 2) One board
WITH u AS (
  SELECT id FROM users WHERE email = 'demo@example.com'
),
b AS (
  INSERT INTO boards (name, owner_id)
  SELECT 'Demo Board', u.id FROM u
  RETURNING id
)
-- 3) Three lists
INSERT INTO lists (board_id, name, position)
SELECT id, 'To Do', 0 FROM b
UNION ALL SELECT id, 'In Progress', 1 FROM b
UNION ALL SELECT id, 'Done', 2 FROM b;

-- 4) A few tasks into "To Do"
WITH
  b AS (SELECT id FROM boards WHERE name = 'Demo Board'),
  l AS (
    SELECT id FROM lists WHERE board_id = (SELECT id FROM b) AND name = 'To Do'
  ),
  u AS (SELECT id FROM users WHERE email = 'demo@example.com')
INSERT INTO tasks (list_id, title, description, position, status, created_by, due_date)
SELECT (SELECT id FROM l), 'Wire API → DB', 'Ping DB + version()', 0, 'in_progress', (SELECT id FROM u), CURRENT_DATE + 3
UNION ALL
SELECT (SELECT id FROM l), 'Add migrations', 'users, boards, lists, tasks, comments', 1, 'todo', (SELECT id FROM u), CURRENT_DATE + 5
UNION ALL
SELECT (SELECT id FROM l), 'Vue proxy', 'Vite → Go via /api/*', 2, 'todo', (SELECT id FROM u), NULL;

-- 5) Assign demo user to first task
WITH t AS (
  SELECT id FROM tasks ORDER BY created_at ASC LIMIT 1
),
u AS (SELECT id FROM users WHERE email = 'demo@example.com')
INSERT INTO task_assignees (task_id, user_id)
SELECT t.id, u.id FROM t, u
ON CONFLICT DO NOTHING;

-- 6) One comment on first task
WITH t AS (
  SELECT id FROM tasks ORDER BY created_at ASC LIMIT 1
),
u AS (SELECT id FROM users WHERE email = 'demo@example.com')
INSERT INTO comments (task_id, author_id, body)
SELECT t.id, u.id, 'First!' FROM t, u;



-- Workspaces (demo)
WITH u AS (
  SELECT id FROM users WHERE email = 'demo@example.com'
),
w AS (
  INSERT INTO workspaces (name, slug)
  VALUES ('Demo Workspace', 'demo')
  ON CONFLICT (slug) DO UPDATE SET name = EXCLUDED.name
  RETURNING id
)
INSERT INTO workspace_members (workspace_id, user_id, role)
SELECT w.id, u.id, 'owner' FROM w, u
ON CONFLICT DO NOTHING;

-- Attach existing boards to demo workspace if not set
UPDATE boards
SET workspace_id = (SELECT id FROM workspaces WHERE slug = 'demo')
WHERE workspace_id IS NULL;

===== END FILE =====


===== BEGIN FILE: docker-compose.yml =====

services:
    db:
        image: postgres:16
        container_name: tm_db
        restart: unless-stopped
        environment:
            POSTGRES_USER: ${POSTGRES_USER}
            POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
            POSTGRES_DB: ${POSTGRES_DB}
        ports:
            - "5432:5432"
        volumes:
            - pgdata:/var/lib/postgresql/data

    pgadmin:
        image: dpage/pgadmin4
        container_name: tm_pgadmin
        restart: unless-stopped
        environment:
            PGADMIN_DEFAULT_EMAIL: ${PGADMIN_DEFAULT_EMAIL}
            PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_DEFAULT_PASSWORD}
        ports:
            - "5050:80"
        depends_on:
            - db
    api:
        build:
            context: ./server
            dockerfile: Dockerfile
        container_name: tm_api
        command: ["air", "-c", ".air.toml", "-build.poll", "true", "-build.poll_interval", "1000"]
        working_dir: /app
        volumes:
            - ./server:/app
        ports:
            - "8080:8080"
        depends_on:
            - db
        environment:
            - DB_DSN=${DB_DSN}

    web:
        build:
            context: ./web
            dockerfile: Dockerfile
        container_name: tm_web
        command:
            ["bash", "-lc", "corepack enable && corepack prepare pnpm@9 --activate && pnpm install && pnpm dev --host"]
        working_dir: /app
        volumes:
            - ./web:/app
            - /app/node_modules
            - pnpmstore:/app/.pnpm-store
        ports:
            - "5173:5173"
        depends_on:
            - api

    migrate:
        image: migrate/migrate:4
        volumes:
            - ./db/migrations:/migrations
        depends_on:
            - db
        entrypoint: ["migrate"]
        command: ["-path", "/migrations", "-database", "postgres://app:app@db:5432/taskmgr?sslmode=disable", "up"]

    seed:
        image: postgres:16
        depends_on:
            - db
        volumes:
            - ./db/seed:/seed
        environment:
            PGPASSWORD: ${POSTGRES_PASSWORD}
        entrypoint: ["psql"]
        command: ["-h", "db", "-U", "${POSTGRES_USER}", "-d", "${POSTGRES_DB}", "-f", "/seed/seed.sql"]

volumes:
    pgdata:
    pnpmstore:


===== END FILE =====


===== BEGIN FILE: project_snapshot_2025-09-19_20-33-31.txt =====

### PROJECT SNAPSHOT
Generated: 2025-09-19 20:33:31 +03:00
Root: C:\Users\denis\Desktop\docker-projects\task-manager

--- PROJECT STRUCTURE (filtered) ---

[DIR] .
  - .env
  - .env.example
  - .gitignore
  - auth-testuser.ps1
  - cookies.txt
  - docker-compose.yml
  - README.md
[DIR] db\migrations
  - 0001_users.down.sql
  - 0001_users.up.sql
  - 0002_boards_and_lists.down.sql
  - 0002_boards_and_lists.up.sql
  - 0003_tasks.down.sql
  - 0003_tasks.up.sql
  - 0004_task_creator_and_assignees.down.sql
  - 0004_task_creator_and_assignees.up.sql
  - 0005_comments.down.sql
  - 0005_comments.up.sql
  - 0006_workspaces.down.sql
  - 0006_workspaces.up.sql
[DIR] db\seed
  - seed.sql
[DIR] server
  - .air.toml
  - Dockerfile
  - go.mod
[DIR] server\cmd\api
  - handlers_auth.go
  - handlers_board.go
  - handlers_comments.go
  - handlers_tasks.go
  - handlers_uploads.go
  - main.go
  - routes.go
[DIR] web
  - .env
  - .gitignore
  - Dockerfile
  - index.html
  - package.json
  - README.md
  - vite.config.js
[DIR] web\public
  - vite.svg
[DIR] web\src
  - App.vue
  - main.js
  - router.js
  - style.css
[DIR] web\src\assets
  - vue.svg
[DIR] web\src\components
  - HelloWorld.vue
  - RichEditor.vue
  - SafeHtml.vue
  - TaskModal.vue
[DIR] web\src\lib
  - api.js
[DIR] web\src\stores
  - auth.js
[DIR] web\src\views
  - Board.vue
  - Home.vue
  - Login.vue
  - Register.vue

--- FILE CONTENTS (filtered) ---


===== BEGIN FILE: .env =====

POSTGRES_USER=app
POSTGRES_PASSWORD=app
POSTGRES_DB=taskmgr
PGADMIN_DEFAULT_EMAIL=admin@example.com
PGADMIN_DEFAULT_PASSWORD=admin123
DB_DSN=postgres://app:app@db:5432/taskmgr?sslmode=disable

===== END FILE =====


===== BEGIN FILE: .env.example =====

POSTGRES_USER=app
POSTGRES_PASSWORD=app
POSTGRES_DB=taskmgr
PGADMIN_DEFAULT_EMAIL=admin@example.com
PGADMIN_DEFAULT_PASSWORD=admin123
DB_DSN=postgres://app:app@db:5432/taskmgr?sslmode=disable

===== END FILE =====


===== BEGIN FILE: .gitignore =====

# Node
node_modules/
web/node_modules/

# pnpm store (root + nested)
.pnpm-store/
web/.pnpm-store/
**/.pnpm-store/

# Build output
dist/

# Environment files
.env
.env.local
.env.*.local

# Editor/IDE settings
.vscode/
.idea/

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# OS junk
.DS_Store
Thumbs.db

uploads/



# pnpm store (root + nested)
.pnpm-store/
web/.pnpm-store/
**/.pnpm-store/

# VS Code anywhere
**/.vscode/


# dev artifacts
cookies.txt
server/uploads/
server/tmp/
web/.env
web/node_modules/
web/dist/

===== END FILE =====


===== BEGIN FILE: auth-testuser.ps1 =====

param(
  [string]$Email = "test@example.com",
  [string]$Password = "test123"
)

# Build login JSON
$login = @{ email=$Email; password=$Password } | ConvertTo-Json -Compress

# Save cookies
curl.exe -s -i -c cookies.txt -b cookies.txt `
  -X POST http://localhost:5173/api/login `
  -H "Content-Type: application/json" `
  --data-binary "$login" | Out-Null

# Verify
$me = curl.exe -s -b cookies.txt http://localhost:5173/api/me | ConvertFrom-Json
Write-Host "Logged in as $($me.name) <$($me.email)>, user_id=$($me.id)"


===== END FILE =====


===== BEGIN FILE: cookies.txt =====

# Netscape HTTP Cookie File
# https://curl.se/docs/http-cookies.html
# This file was generated by libcurl! Edit at your own risk.

localhost	FALSE	/	FALSE	0	csrf	gaegEn9GmjuBVtt8Fv48Ha3-e2l3cyD9
#HttpOnly_localhost	FALSE	/	FALSE	0	sid	qxCGf8dl61tONygpRIPsKLYTClHljduc


===== END FILE =====


===== BEGIN FILE: db\migrations\0001_users.down.sql =====

DROP TABLE IF EXISTS users;


===== END FILE =====


===== BEGIN FILE: db\migrations\0001_users.up.sql =====

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE IF NOT EXISTS users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  email TEXT NOT NULL UNIQUE,
  password_hash TEXT NOT NULL,
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);


===== END FILE =====


===== BEGIN FILE: db\migrations\0002_boards_and_lists.down.sql =====

DROP TABLE IF EXISTS lists;
DROP TABLE IF EXISTS boards;

===== END FILE =====


===== BEGIN FILE: db\migrations\0002_boards_and_lists.up.sql =====

-- Boards hold lists; simple for now (owner_id optional for later).
CREATE TABLE IF NOT EXISTS boards (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  owner_id UUID NULL REFERENCES users(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Lists (columns) belong to a board; position supports ordering left→right.
CREATE TABLE IF NOT EXISTS lists (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  board_id UUID NOT NULL REFERENCES boards(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  position INT NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Helpful indexes
CREATE INDEX IF NOT EXISTS idx_lists_board ON lists(board_id);
CREATE INDEX IF NOT EXISTS idx_lists_board_position ON lists(board_id, position);


===== END FILE =====


===== BEGIN FILE: db\migrations\0003_tasks.down.sql =====

DROP TABLE IF EXISTS tasks;

===== END FILE =====


===== BEGIN FILE: db\migrations\0003_tasks.up.sql =====

CREATE TABLE IF NOT EXISTS tasks (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  list_id UUID NOT NULL REFERENCES lists(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT NOT NULL DEFAULT '',
  position INT NOT NULL DEFAULT 0,                    -- order within a list (left→right top→bottom)
  status TEXT NOT NULL DEFAULT 'todo',                -- we'll normalize later if needed
  assignee_id UUID NULL REFERENCES users(id) ON DELETE SET NULL,
  due_date DATE NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- quick lookups & ordered pulls
CREATE INDEX IF NOT EXISTS idx_tasks_list ON tasks(list_id);
CREATE INDEX IF NOT EXISTS idx_tasks_list_position ON tasks(list_id, position);
CREATE INDEX IF NOT EXISTS idx_tasks_assignee ON tasks(assignee_id);


===== END FILE =====


===== BEGIN FILE: db\migrations\0004_task_creator_and_assignees.down.sql =====

DROP TABLE IF EXISTS task_assignees;
ALTER TABLE tasks DROP COLUMN IF EXISTS created_by;

===== END FILE =====


===== BEGIN FILE: db\migrations\0004_task_creator_and_assignees.up.sql =====

-- Add creator to tasks
ALTER TABLE tasks
  ADD COLUMN created_by UUID NULL REFERENCES users(id) ON DELETE SET NULL;

-- Many-to-many assignees
CREATE TABLE IF NOT EXISTS task_assignees (
  task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  assigned_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  PRIMARY KEY (task_id, user_id)
);

-- Helpful indexes (optional but nice)
CREATE INDEX IF NOT EXISTS idx_task_assignees_user ON task_assignees(user_id);


===== END FILE =====


===== BEGIN FILE: db\migrations\0005_comments.down.sql =====

DROP TABLE IF EXISTS comments;

===== END FILE =====


===== BEGIN FILE: db\migrations\0005_comments.up.sql =====

CREATE TABLE IF NOT EXISTS comments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  task_id   UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
  author_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  body TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_comments_task ON comments(task_id);


===== END FILE =====


===== BEGIN FILE: db\migrations\0006_workspaces.down.sql =====

ALTER TABLE boards DROP COLUMN IF EXISTS workspace_id;
DROP TABLE IF EXISTS workspace_members;
DROP TABLE IF EXISTS workspaces;


===== END FILE =====


===== BEGIN FILE: db\migrations\0006_workspaces.up.sql =====

CREATE TABLE IF NOT EXISTS workspaces (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  slug TEXT UNIQUE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS workspace_members (
  workspace_id UUID NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  role TEXT NOT NULL DEFAULT 'member',
  PRIMARY KEY (workspace_id, user_id)
);

ALTER TABLE boards
  ADD COLUMN workspace_id UUID NULL REFERENCES workspaces(id) ON DELETE CASCADE;

CREATE INDEX IF NOT EXISTS idx_boards_workspace ON boards(workspace_id);


===== END FILE =====


===== BEGIN FILE: db\seed\seed.sql =====

-- DEV-ONLY SEED. Run after `migrate up` on an empty DB.

-- 1) One demo user
INSERT INTO users (email, password_hash, name)
VALUES ('demo@example.com', 'x', 'Demo User')
ON CONFLICT (email) DO NOTHING;

-- 2) One board
WITH u AS (
  SELECT id FROM users WHERE email = 'demo@example.com'
),
b AS (
  INSERT INTO boards (name, owner_id)
  SELECT 'Demo Board', u.id FROM u
  RETURNING id
)
-- 3) Three lists
INSERT INTO lists (board_id, name, position)
SELECT id, 'To Do', 0 FROM b
UNION ALL SELECT id, 'In Progress', 1 FROM b
UNION ALL SELECT id, 'Done', 2 FROM b;

-- 4) A few tasks into "To Do"
WITH
  b AS (SELECT id FROM boards WHERE name = 'Demo Board'),
  l AS (
    SELECT id FROM lists WHERE board_id = (SELECT id FROM b) AND name = 'To Do'
  ),
  u AS (SELECT id FROM users WHERE email = 'demo@example.com')
INSERT INTO tasks (list_id, title, description, position, status, created_by, due_date)
SELECT (SELECT id FROM l), 'Wire API → DB', 'Ping DB + version()', 0, 'in_progress', (SELECT id FROM u), CURRENT_DATE + 3
UNION ALL
SELECT (SELECT id FROM l), 'Add migrations', 'users, boards, lists, tasks, comments', 1, 'todo', (SELECT id FROM u), CURRENT_DATE + 5
UNION ALL
SELECT (SELECT id FROM l), 'Vue proxy', 'Vite → Go via /api/*', 2, 'todo', (SELECT id FROM u), NULL;

-- 5) Assign demo user to first task
WITH t AS (
  SELECT id FROM tasks ORDER BY created_at ASC LIMIT 1
),
u AS (SELECT id FROM users WHERE email = 'demo@example.com')
INSERT INTO task_assignees (task_id, user_id)
SELECT t.id, u.id FROM t, u
ON CONFLICT DO NOTHING;

-- 6) One comment on first task
WITH t AS (
  SELECT id FROM tasks ORDER BY created_at ASC LIMIT 1
),
u AS (SELECT id FROM users WHERE email = 'demo@example.com')
INSERT INTO comments (task_id, author_id, body)
SELECT t.id, u.id, 'First!' FROM t, u;



-- Workspaces (demo)
WITH u AS (
  SELECT id FROM users WHERE email = 'demo@example.com'
),
w AS (
  INSERT INTO workspaces (name, slug)
  VALUES ('Demo Workspace', 'demo')
  ON CONFLICT (slug) DO UPDATE SET name = EXCLUDED.name
  RETURNING id
)
INSERT INTO workspace_members (workspace_id, user_id, role)
SELECT w.id, u.id, 'owner' FROM w, u
ON CONFLICT DO NOTHING;

-- Attach existing boards to demo workspace if not set
UPDATE boards
SET workspace_id = (SELECT id FROM workspaces WHERE slug = 'demo')
WHERE workspace_id IS NULL;

===== END FILE =====


===== BEGIN FILE: docker-compose.yml =====

services:
    db:
        image: postgres:16
        container_name: tm_db
        restart: unless-stopped
        environment:
            POSTGRES_USER: ${POSTGRES_USER}
            POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
            POSTGRES_DB: ${POSTGRES_DB}
        ports:
            - "5432:5432"
        volumes:
            - pgdata:/var/lib/postgresql/data

    pgadmin:
        image: dpage/pgadmin4
        container_name: tm_pgadmin
        restart: unless-stopped
        environment:
            PGADMIN_DEFAULT_EMAIL: ${PGADMIN_DEFAULT_EMAIL}
            PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_DEFAULT_PASSWORD}
        ports:
            - "5050:80"
        depends_on:
            - db
    api:
        build:
            context: ./server
            dockerfile: Dockerfile
        container_name: tm_api
        command: ["air", "-c", ".air.toml", "-build.poll", "true", "-build.poll_interval", "1000"]
        working_dir: /app
        volumes:
            - ./server:/app
        ports:
            - "8080:8080"
        depends_on:
            - db
        environment:
            - DB_DSN=${DB_DSN}

    web:
        build:
            context: ./web
            dockerfile: Dockerfile
        container_name: tm_web
        command:
            ["bash", "-lc", "corepack enable && corepack prepare pnpm@9 --activate && pnpm install && pnpm dev --host"]
        working_dir: /app
        volumes:
            - ./web:/app
            - /app/node_modules
            - pnpmstore:/app/.pnpm-store
        ports:
            - "5173:5173"
        depends_on:
            - api

    migrate:
        image: migrate/migrate:4
        volumes:
            - ./db/migrations:/migrations
        depends_on:
            - db
        entrypoint: ["migrate"]
        command: ["-path", "/migrations", "-database", "postgres://app:app@db:5432/taskmgr?sslmode=disable", "up"]

    seed:
        image: postgres:16
        depends_on:
            - db
        volumes:
            - ./db/seed:/seed
        environment:
            PGPASSWORD: ${POSTGRES_PASSWORD}
        entrypoint: ["psql"]
        command: ["-h", "db", "-U", "${POSTGRES_USER}", "-d", "${POSTGRES_DB}", "-f", "/seed/seed.sql"]

volumes:
    pgdata:
    pnpmstore:


===== END FILE =====


===== BEGIN FILE: README.md =====

# Task Manager

Mono-repo with Go API, Vue 3 web app, and Postgres (via Docker).

## Structure
- **server/** � Go backend (API, auth, tasks, comments)
- **web/** � Vue 3 frontend (Vite, Pinia, Router)
- **db/migrations/** � SQL migrations (golang-migrate)
- **docker/** � Dockerfiles / scripts
- **docker-compose.yml** � (later) dev stack runner

## Dev Targets (MVP)
- Auth: register/login/logout
- Tasks: CRUD, assign, status, due date
- Comments: per task
- Filters/search

## Next Steps
1) Skeleton now.
2) Prereqs: Docker Desktop, Go, Node LTS.
3) Docker Compose for dev (db/api/web).
4) Minimal health endpoints.
## DB Quick Access
- pgAdmin: http://localhost:5050  
  - Add Server ? Host: db, User: app, Password: app


===== END FILE =====


===== BEGIN FILE: server\.air.toml =====

root = "."
tmp_dir = "tmp"
poll = true
poll_interval = 1000
[build]
cmd = "go build -o ./tmp/api ./cmd/api"
bin = "./tmp/api"
include_ext = ["go"]
exclude_dir = ["tmp","vendor"]
delay = 1000


===== END FILE =====


===== BEGIN FILE: server\cmd\api\handlers_auth.go =====

package main

import (
	"crypto/rand"
	"database/sql"
	"encoding/base64"
	"encoding/json"
	"log"
	"net/http"
	"strings"
	"sync"
	"time"

	"golang.org/x/crypto/argon2"
)

// ---- password hashing ----

func hashPassword(pw string) (string, error) {
	salt := make([]byte, 16)
	if _, err := rand.Read(salt); err != nil {
		return "", err
	}
	const (
		timeCost    = 3
		memoryCost  = 64 * 1024
		parallelism = 1
		keyLen      = 32
	)
	dk := argon2.IDKey([]byte(pw), salt, timeCost, memoryCost, uint8(parallelism), keyLen)
	return "$argon2id$v=19$m=65536,t=3,p=1$" +
		base64.RawStdEncoding.EncodeToString(salt) + "$" +
		base64.RawStdEncoding.EncodeToString(dk), nil
}

func verifyPassword(pw, encoded string) bool {
	parts := strings.Split(encoded, "$")
	if len(parts) != 6 || parts[1] != "argon2id" {
		return false
	}
	salt, err1 := base64.RawStdEncoding.DecodeString(parts[4])
	want, err2 := base64.RawStdEncoding.DecodeString(parts[5])
	if err1 != nil || err2 != nil {
		return false
	}
	dk := argon2.IDKey([]byte(pw), salt, 3, 64*1024, 1, uint32(len(want)))
	if len(dk) != len(want) {
		return false
	}
	var v byte
	for i := range dk {
		v |= dk[i] ^ want[i]
	}
	return v == 0
}

// ---- session store (dev-only) ----

type Session struct {
	UserID  string
	CSRF    string
	Expires time.Time
}

var (
	sessions   = make(map[string]Session)
	sessionsMu sync.Mutex
)

func randToken(n int) string {
	b := make([]byte, n)
	_, _ = rand.Read(b)
	return base64.RawURLEncoding.EncodeToString(b) // URL-safe
}

// ---- /api/register ----

type registerReq struct {
	Email    string `json:"email"`
	Name     string `json:"name"`
	Password string `json:"password"`
}
type registerResp struct {
	ID    string `json:"id"`
	Email string `json:"email"`
	Name  string `json:"name"`
}

func registerHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	var req registerReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "bad json", http.StatusBadRequest)
		return
	}
	if req.Email == "" || req.Password == "" || req.Name == "" {
		http.Error(w, "missing fields", http.StatusBadRequest)
		return
	}
	h, err := hashPassword(req.Password)
	if err != nil {
		http.Error(w, "hashing failed", http.StatusInternalServerError)
		return
	}
	var id string
	err = db.QueryRow(
		`INSERT INTO users (email, password_hash, name) VALUES ($1,$2,$3) RETURNING id`,
		req.Email, h, req.Name,
	).Scan(&id)
	if err != nil {
		http.Error(w, "could not create user", http.StatusConflict)
		return
	}

	// 👇 best-effort provisioning (workspace + default board + lists)
	if err := provisionPersonalWorkspace(db, id, req.Name); err != nil {
		// Non-fatal for registration; just log it. User can still log in.
		log.Println("provisioning failed:", err)
	}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(registerResp{ID: id, Email: req.Email, Name: req.Name})
}

func provisionPersonalWorkspace(db *sql.DB, userID, userName string) error {
	tx, err := db.Begin()
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			_ = tx.Rollback()
		}
	}()

	// 1) workspace (slug NULL for now; keep it simple)
	var wsID string
	if err = tx.QueryRow(
		`INSERT INTO workspaces (name, slug) VALUES ($1, NULL) RETURNING id`,
		userName+"'s Workspace",
	).Scan(&wsID); err != nil {
		return err
	}

	// 2) membership (owner)
	if _, err = tx.Exec(
		`INSERT INTO workspace_members (workspace_id, user_id, role) VALUES ($1,$2,'owner')
         ON CONFLICT DO NOTHING`,
		wsID, userID,
	); err != nil {
		return err
	}

	// 3) default board
	var boardID string
	if err = tx.QueryRow(
		`INSERT INTO boards (name, owner_id, workspace_id) VALUES ($1,$2,$3) RETURNING id`,
		"My Board", userID, wsID,
	).Scan(&boardID); err != nil {
		return err
	}

	// 4) three starter lists
	if _, err = tx.Exec(
		`INSERT INTO lists (board_id, name, position)
         VALUES ($1,'To Do',0), ($1,'In Progress',1), ($1,'Done',2)`,
		boardID,
	); err != nil {
		return err
	}

	// 4.1) three example tasks in "To Do"
	var todoListID string
	if err = tx.QueryRow(
		`SELECT id FROM lists WHERE board_id=$1 AND name='To Do' LIMIT 1`,
		boardID,
	).Scan(&todoListID); err != nil {
		return err
	}
	if _, err = tx.Exec(
		`INSERT INTO tasks (list_id, title, description, position, status, created_by)
         VALUES
         ($1, 'Welcome to your board', 'Drag cards between lists as work progresses.', 0, 'todo', $2),
         ($1, 'Create your first task', 'Click + to add tasks. Assign teammates later.', 1, 'todo', $2),
         ($1, 'Invite a teammate', 'Collaborate by inviting others to your workspace.', 2, 'todo', $2)`,
		todoListID, userID,
	); err != nil {
		return err
	}

	return tx.Commit()
}

// ---- /api/login ----

type loginReq struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}
type loginResp struct {
	UserID string `json:"user_id"`
}

func loginHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	var req loginReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "bad json", http.StatusBadRequest)
		return
	}
	if req.Email == "" || req.Password == "" {
		http.Error(w, "missing fields", http.StatusBadRequest)
		return
	}
	var userID, pwHash string
	err := db.QueryRow(`SELECT id, password_hash FROM users WHERE email=$1`, req.Email).Scan(&userID, &pwHash)
	if err == sql.ErrNoRows {
		http.Error(w, "invalid credentials", http.StatusUnauthorized)
		return
	} else if err != nil {
		http.Error(w, "login failed", http.StatusInternalServerError)
		return
	}
	if !verifyPassword(req.Password, pwHash) {
		http.Error(w, "invalid credentials", http.StatusUnauthorized)
		return
	}
	sid := randToken(24)
	csrf := randToken(24)
	sessionsMu.Lock()
	sessions[sid] = Session{UserID: userID, CSRF: csrf, Expires: time.Now().Add(24 * time.Hour)}
	sessionsMu.Unlock()

	http.SetCookie(w, &http.Cookie{
		Name:     "sid",
		Value:    sid,
		Path:     "/",
		HttpOnly: true,
		SameSite: http.SameSiteLaxMode,
	})
	http.SetCookie(w, &http.Cookie{
		Name:     "csrf",
		Value:    csrf,
		Path:     "/",
		HttpOnly: false,
		SameSite: http.SameSiteLaxMode,
	})
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(loginResp{UserID: userID})
}

// ---- /api/me ----

type meResp struct {
	ID    string `json:"id"`
	Email string `json:"email"`
	Name  string `json:"name"`
}

func getSessionFromRequest(r *http.Request) (Session, bool) {
	c, err := r.Cookie("sid")
	if err != nil || c.Value == "" {
		return Session{}, false
	}
	sessionsMu.Lock()
	s, ok := sessions[c.Value]
	sessionsMu.Unlock()
	if !ok || time.Now().After(s.Expires) {
		return Session{}, false
	}
	return s, true
}

func meHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	if r.Method != http.MethodGet {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	sess, ok := getSessionFromRequest(r)
	if !ok {
		http.Error(w, "unauthorized", http.StatusUnauthorized)
		return
	}
	var email, name string
	if err := db.QueryRow(`SELECT email, name FROM users WHERE id=$1`, sess.UserID).Scan(&email, &name); err != nil {
		http.Error(w, "user not found", http.StatusUnauthorized)
		return
	}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(meResp{ID: sess.UserID, Email: email, Name: name})
}

// ---- CSRF helper for POST/PUT/PATCH/DELETE ----

func requireAuthAndCSRF(w http.ResponseWriter, r *http.Request) (Session, bool) {
	s, ok := getSessionFromRequest(r)
	if !ok {
		http.Error(w, "unauthorized", http.StatusUnauthorized)
		return Session{}, false
	}
	token := r.Header.Get("X-CSRF-Token")
	if token == "" || token != s.CSRF {
		http.Error(w, "forbidden", http.StatusForbidden)
		return Session{}, false
	}
	return s, true
}

func logoutHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Best-effort: remove session by cookie value
	if sid, ok := readSIDCookie(r); ok {
		deleteSessionByID(sid)
	}

	// Expire cookies
	http.SetCookie(w, &http.Cookie{
		Name:     "sid",
		Value:    "",
		Path:     "/",
		HttpOnly: true,
		SameSite: http.SameSiteLaxMode,
		MaxAge:   -1,
	})
	http.SetCookie(w, &http.Cookie{
		Name:     "csrf",
		Value:    "",
		Path:     "/",
		SameSite: http.SameSiteLaxMode,
		MaxAge:   -1,
	})

	w.Header().Set("Content-Type", "application/json")
	_, _ = w.Write([]byte(`{"ok":true}`))
}

// readSIDCookie extracts the session id from the "sid" cookie.
func readSIDCookie(r *http.Request) (string, bool) {
	c, err := r.Cookie("sid")
	if err != nil || c.Value == "" {
		return "", false
	}
	return c.Value, true
}

// deleteSessionByID removes a session from the in-memory store.
// Relies on the existing `sessions` map and `sessionsMu` mutex defined above.
func deleteSessionByID(sid string) {
	sessionsMu.Lock()
	defer sessionsMu.Unlock()
	delete(sessions, sid)
}


===== END FILE =====


===== BEGIN FILE: server\cmd\api\handlers_board.go =====

package main

import (
	"database/sql"
	"encoding/json"
	"net/http"
)

// ---- DTOs for board payload ----

type BoardDTO struct {
	ID    string    `json:"id"`
	Name  string    `json:"name"`
	Lists []ListDTO `json:"lists"`
}

type ListDTO struct {
	ID       string    `json:"id"`
	Name     string    `json:"name"`
	Position int       `json:"position"`
	Tasks    []TaskDTO `json:"tasks"`
}

type TaskDTO struct {
	ID           string   `json:"id"`
	Title        string   `json:"title"`
	Description  string   `json:"description"`
	Status       string   `json:"status"`
	Position     int      `json:"position"`
	Assignees    []string `json:"assignees"`
	CommentCount int      `json:"comment_count"`
}

// ---- Handler ----

func boardsHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	// 🔐 now requires auth (so we can scope by workspace membership)
	sess, ok := getSessionFromRequest(r)
	if !ok {
		http.Error(w, "unauthorized", http.StatusUnauthorized)
		return
	}

	qid := r.URL.Query().Get("id")
	inc := r.URL.Query().Get("include")

	var wantLists, wantTasks bool
	switch inc {
	case "", "lists,tasks":
		wantLists, wantTasks = true, true
	case "lists":
		wantLists, wantTasks = true, false
	default:
		wantLists, wantTasks = false, false
	}

	// 1) board (scoped to user's workspace membership)
	var boardID, boardName string
	var err error
	if qid != "" {
		err = db.QueryRow(`
            SELECT b.id, b.name
            FROM boards b
            JOIN workspace_members m ON m.workspace_id = b.workspace_id
            WHERE m.user_id = $1 AND b.id = $2
        `, sess.UserID, qid).Scan(&boardID, &boardName)
		if err == sql.ErrNoRows {
			http.Error(w, "board not found", http.StatusNotFound)
			return
		} else if err != nil {
			http.Error(w, "board query failed", http.StatusInternalServerError)
			return
		}
	} else {
		err = db.QueryRow(`
            SELECT b.id, b.name
            FROM boards b
            JOIN workspace_members m ON m.workspace_id = b.workspace_id
            WHERE m.user_id = $1
            ORDER BY b.created_at ASC
            LIMIT 1
        `, sess.UserID).Scan(&boardID, &boardName)
		if err == sql.ErrNoRows {
			http.Error(w, "no board found", http.StatusNotFound)
			return
		} else if err != nil {
			http.Error(w, "board query failed", http.StatusInternalServerError)
			return
		}
	}

	// 2) lists
	lists := make([]ListDTO, 0)
	if wantLists {
		rows, err := db.Query(`SELECT id, name, position FROM lists WHERE board_id=$1 ORDER BY position ASC`, boardID)
		if err != nil {
			http.Error(w, "lists query failed", http.StatusInternalServerError)
			return
		}
		defer rows.Close()

		for rows.Next() {
			var l ListDTO
			if err := rows.Scan(&l.ID, &l.Name, &l.Position); err == nil {
				l.Tasks = make([]TaskDTO, 0) // non-nil slice
				lists = append(lists, l)
			}
		}
	}

	// 3) tasks per list
	if wantTasks {
		for i := range lists {
			trows, err := db.Query(`SELECT id, title, description, status, position FROM tasks WHERE list_id=$1 ORDER BY position ASC`, lists[i].ID)
			if err != nil {
				http.Error(w, "tasks query failed", http.StatusInternalServerError)
				return
			}
			tasks := make([]TaskDTO, 0)
			for trows.Next() {
				var t TaskDTO
				if err := trows.Scan(&t.ID, &t.Title, &t.Description, &t.Status, &t.Position); err == nil {
					// assignees
					arows, _ := db.Query(`SELECT user_id FROM task_assignees WHERE task_id=$1`, t.ID)
					aids := make([]string, 0)
					for arows.Next() {
						var uid string
						if err := arows.Scan(&uid); err == nil {
							aids = append(aids, uid)
						}
					}
					arows.Close()
					t.Assignees = aids

					// comment count
					_ = db.QueryRow(`SELECT COUNT(*) FROM comments WHERE task_id=$1`, t.ID).Scan(&t.CommentCount)

					tasks = append(tasks, t)
				}
			}
			trows.Close()
			lists[i].Tasks = tasks
		}
	}

	// 4) respond
	payload := BoardDTO{ID: boardID, Name: boardName, Lists: lists}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(payload)
}


===== END FILE =====


===== BEGIN FILE: server\cmd\api\handlers_comments.go =====

package main

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"strings"
	"time"
)

// ---- DTOs ----
type createCommentReq struct {
	TaskID string `json:"task_id"`
	Body   string `json:"body"`
}
type commentResp struct {
	ID        string    `json:"id"`
	TaskID    string    `json:"task_id"`
	AuthorID  string    `json:"author_id"`
	Body      string    `json:"body"`
	CreatedAt time.Time `json:"created_at"`
}
type commentItem struct {
	ID        string    `json:"id"`
	TaskID    string    `json:"task_id"`
	AuthorID  string    `json:"author_id"`
	Body      string    `json:"body"`
	CreatedAt time.Time `json:"created_at"`
}

// ---- POST /api/comments (auth + CSRF) ----
func createCommentHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	sess, ok := requireAuthAndCSRF(w, r)
	if !ok {
		return
	}

	var req createCommentReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil || req.TaskID == "" || strings.TrimSpace(req.Body) == "" {
		http.Error(w, "bad json", http.StatusBadRequest)
		return
	}

	var id string
	var created time.Time
	if err := db.QueryRow(
		`INSERT INTO comments (task_id, author_id, body) VALUES ($1,$2,$3) RETURNING id, created_at`,
		req.TaskID, sess.UserID, req.Body,
	).Scan(&id, &created); err != nil {
		http.Error(w, "insert failed", http.StatusBadRequest)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(commentResp{
		ID: id, TaskID: req.TaskID, AuthorID: sess.UserID, Body: req.Body, CreatedAt: created,
	})
}

// ---- GET /api/comments?task_id=... (public) ----
func listCommentsHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	if r.Method != http.MethodGet {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	taskID := r.URL.Query().Get("task_id")
	if taskID == "" {
		http.Error(w, "missing task_id", http.StatusBadRequest)
		return
	}
	rows, err := db.Query(`
		SELECT id, task_id, author_id, body, created_at
		FROM comments
		WHERE task_id = $1
		ORDER BY created_at ASC
	`, taskID)
	if err != nil {
		http.Error(w, "query failed", http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	items := make([]commentItem, 0)
	for rows.Next() {
		var c commentItem
		if err := rows.Scan(&c.ID, &c.TaskID, &c.AuthorID, &c.Body, &c.CreatedAt); err == nil {
			items = append(items, c)
		}
	}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(items)
}


===== END FILE =====


===== BEGIN FILE: server\cmd\api\handlers_tasks.go =====

// handlers_tasks.go
package main

import (
	"database/sql"
	"encoding/json"
	"log"
	"net/http"
	"strconv"
	"strings"
)

type createTaskReq struct {
	ListID      string `json:"list_id"`
	Title       string `json:"title"`
	Description string `json:"description,omitempty"`
}

type taskCreatedResp struct {
	ID          string `json:"id"`
	ListID      string `json:"list_id"`
	Title       string `json:"title"`
	Description string `json:"description"`
	Position    int    `json:"position"`
	Status      string `json:"status"`
}

func createTaskHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	sess, ok := requireAuthAndCSRF(w, r) // reuse helper
	if !ok {
		return
	}

	var req createTaskReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "bad json", http.StatusBadRequest)
		return
	}
	req.Title = strings.TrimSpace(req.Title)
	if req.ListID == "" || req.Title == "" {
		http.Error(w, "missing fields", http.StatusBadRequest)
		return
	}

	// Ensure the list belongs to a board in a workspace the user is a member of
	var valid bool
	if err := db.QueryRow(`
		SELECT EXISTS(
		  SELECT 1
		  FROM lists l
		  JOIN boards b ON b.id = l.board_id
		  JOIN workspace_members m ON m.workspace_id = b.workspace_id
		  WHERE l.id = $1 AND m.user_id = $2
		)
	`, req.ListID, sess.UserID).Scan(&valid); err != nil || !valid {
		http.Error(w, "forbidden", http.StatusForbidden)
		return
	}

	// Next position in the list
	var nextPos int
	_ = db.QueryRow(`SELECT COALESCE(MAX(position)+1, 0) FROM tasks WHERE list_id=$1`, req.ListID).Scan(&nextPos)

	// Insert
	var id, status string
	if err := db.QueryRow(`
		INSERT INTO tasks (list_id, title, description, position, status, created_by)
		VALUES ($1,$2,$3,$4,'todo',$5)
		RETURNING id, status
	`, req.ListID, req.Title, req.Description, nextPos, sess.UserID).Scan(&id, &status); err != nil {
		http.Error(w, "insert failed", http.StatusBadRequest)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(taskCreatedResp{
		ID: id, ListID: req.ListID, Title: req.Title, Position: nextPos, Status: status,
	})
}

type updateTaskReq struct {
	Title       *string `json:"title,omitempty"`
	Description *string `json:"description,omitempty"`
}

func updateTaskHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	sess, ok := requireAuthAndCSRF(w, r)
	if !ok {
		return
	}

	id := r.URL.Query().Get("id")
	if id == "" {
		http.Error(w, "missing id", http.StatusBadRequest)
		return
	}

	var req updateTaskReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "bad json", http.StatusBadRequest)
		return
	}

	// Build dynamic SET clause with correct $1, $2, ...
	sets := []string{}
	args := []any{}

	if req.Title != nil {
		sets = append(sets, "title=$"+strconv.Itoa(len(args)+1))
		args = append(args, strings.TrimSpace(*req.Title))
	}
	if req.Description != nil {
		sets = append(sets, "description=$"+strconv.Itoa(len(args)+1))
		args = append(args, *req.Description)
	}
	if len(sets) == 0 {
		http.Error(w, "nothing to update", http.StatusBadRequest)
		return
	}

	// WHERE placeholders come after SET args
	//  ... id is next
	args = append(args, id)
	idPos := len(args) // position of id we just appended

	//  ... user id is after that
	args = append(args, sess.UserID)
	userPos := len(args)

	query := `
		UPDATE tasks t
		SET ` + strings.Join(sets, ", ") + `, updated_at=NOW()
		WHERE t.id=$` + strconv.Itoa(idPos) + `
		AND EXISTS (
			SELECT 1
			FROM lists l
			JOIN boards b ON b.id = l.board_id
			JOIN workspace_members m ON m.workspace_id = b.workspace_id
			WHERE l.id = t.list_id AND m.user_id = $` + strconv.Itoa(userPos) + `
		)
		RETURNING t.id, t.title, t.description, t.status, t.position
	`

	log.Printf("[updateTaskHandler] query OK:\n%s\nargs: %#v", query, args)

	var out taskCreatedResp
	// taskCreatedResp now includes Description (you already added it)
	if err := db.QueryRow(query, args...).Scan(&out.ID, &out.Title, &out.Description, &out.Status, &out.Position); err != nil {
		http.Error(w, "update failed", http.StatusBadRequest)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(out)
}

func deleteTaskHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	sess, ok := requireAuthAndCSRF(w, r)
	if !ok {
		return
	}

	id := r.URL.Query().Get("id")
	if id == "" {
		http.Error(w, "missing id", http.StatusBadRequest)
		return
	}

	res, err := db.Exec(`
        DELETE FROM tasks t
        WHERE t.id=$1
        AND EXISTS (
            SELECT 1
            FROM lists l
            JOIN boards b ON b.id=l.board_id
            JOIN workspace_members m ON m.workspace_id=b.workspace_id
            WHERE l.id=t.list_id AND m.user_id=$2
        )
    `, id, sess.UserID)
	if err != nil {
		http.Error(w, "delete failed", http.StatusBadRequest)
		return
	}
	n, _ := res.RowsAffected()
	if n == 0 {
		http.Error(w, "not found or forbidden", http.StatusNotFound)
		return
	}

	w.WriteHeader(http.StatusNoContent)
}


===== END FILE =====


===== BEGIN FILE: server\cmd\api\handlers_uploads.go =====

package main

import (
	"encoding/json"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"time"
)

var uploadDir = "/app/server/uploads" // absolute path inside the api container

func uploadHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	if err := r.ParseMultipartForm(20 << 20); err != nil {
		http.Error(w, "bad multipart", http.StatusBadRequest)
		return
	}
	file, hdr, err := r.FormFile("file")
	if err != nil {
		http.Error(w, "file missing", http.StatusBadRequest)
		return
	}
	defer file.Close()

	_ = os.MkdirAll(uploadDir, 0o755)

	ext := filepath.Ext(hdr.Filename)
	if ext == "" {
		ext = ".bin"
	}
	name := time.Now().UTC().Format("20060102-150405.000000000") + ext
	dstPath := filepath.Join(uploadDir, name)

	dst, err := os.Create(dstPath)
	if err != nil {
		http.Error(w, "cannot save", http.StatusInternalServerError)
		return
	}
	defer dst.Close()
	if _, err = io.Copy(dst, file); err != nil {
		http.Error(w, "write error", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(map[string]string{
		"url": "/uploads/" + name, // path we serve below
	})
}


===== END FILE =====


===== BEGIN FILE: server\cmd\api\main.go =====

package main

import (
	"database/sql"
	"log"
	"net/http"
	"os"

	_ "github.com/jackc/pgx/v5/stdlib"
)

func main() {
	dsn := os.Getenv("DB_DSN")
	if dsn == "" {
		log.Fatal("DB_DSN not set")
	}

	db, err := sql.Open("pgx", dsn)
	if err != nil {
		log.Fatal("cannot open db:", err)
	}
	defer db.Close()

	if err := db.Ping(); err != nil {
		log.Fatal("cannot ping db:", err)
	}
	log.Println("DB OK")

	var version string
	if err := db.QueryRow("select version()").Scan(&version); err != nil {
		log.Fatal("db query failed:", err)
	}
	log.Println("DB version:", version)

	registerRoutes(db)

	log.Println("API listening on :8080 (with DB)")
	log.Fatal(http.ListenAndServe(":8080", nil))

}


===== END FILE =====


===== BEGIN FILE: server\cmd\api\routes.go =====

// routes.go
package main

import (
	"database/sql"
	"net/http"
)

func registerRoutes(db *sql.DB) {
	http.HandleFunc("/api/boards", func(w http.ResponseWriter, r *http.Request) {
		boardsHandler(w, r, db)
	})
	http.HandleFunc("/api/register", func(w http.ResponseWriter, r *http.Request) {
		registerHandler(w, r, db)
	})
	http.HandleFunc("/api/login", func(w http.ResponseWriter, r *http.Request) {
		loginHandler(w, r, db)
	})
	http.HandleFunc("/api/me", func(w http.ResponseWriter, r *http.Request) {
		meHandler(w, r, db)
	})
	http.HandleFunc("/api/comments", func(w http.ResponseWriter, r *http.Request) {
		switch r.Method {
		case http.MethodGet:
			listCommentsHandler(w, r, db)
		case http.MethodPost:
			createCommentHandler(w, r, db)
		default:
			http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		}
	})
	http.HandleFunc("/api/tasks", func(w http.ResponseWriter, r *http.Request) {
		switch r.Method {
		case http.MethodPost:
			createTaskHandler(w, r, db)
		case http.MethodPatch:
			updateTaskHandler(w, r, db)
		case http.MethodDelete:
			deleteTaskHandler(w, r, db)
		default:
			http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		}
	})
	http.HandleFunc("/api/logout", logoutHandler)
	http.HandleFunc("/api/uploads", uploadHandler)
	http.Handle("/uploads/", http.StripPrefix("/uploads/", http.FileServer(http.Dir(uploadDir))))
}


===== END FILE =====


===== BEGIN FILE: server\Dockerfile =====

# syntax=docker/dockerfile:1
FROM golang:1.25

# Install Air for hot reload
RUN go install github.com/air-verse/air@latest

WORKDIR /app


===== END FILE =====


===== BEGIN FILE: server\go.mod =====

module github.com/ri5pekt/task-manager/server

go 1.25.1

require (
	github.com/jackc/pgx/v5 v5.7.6
	golang.org/x/crypto v0.37.0
)

require (
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect
	github.com/jackc/puddle/v2 v2.2.2 // indirect
	golang.org/x/sync v0.13.0 // indirect
	golang.org/x/sys v0.32.0 // indirect
	golang.org/x/text v0.24.0 // indirect
)


===== END FILE =====


===== BEGIN FILE: web\.env =====

VITE_TINYMCE_API_KEY=78uxnmz8kwnwy75u8b0umcxff4z6tmj3aku9gcoopeb9lfv4

===== END FILE =====


===== BEGIN FILE: web\.gitignore =====

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files

.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
.pnpm-store/
.vscode/


# Dev artifacts
cookies.txt
server/tmp/
project_snapshot_*.txt

# Tailwind v4 (using @tailwindcss/vite, no PostCSS config)
web/postcss.config.js

===== END FILE =====


===== BEGIN FILE: web\Dockerfile =====

# syntax=docker/dockerfile:1
# Placeholder for Vue app image. We�ll add build steps later.
FROM node:20 AS dev
WORKDIR /app
# (deps, dev server, and prod build will be added later)


===== END FILE =====


===== BEGIN FILE: web\index.html =====

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + Vue</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>


===== END FILE =====


===== BEGIN FILE: web\package.json =====

{
  "name": "web",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@headlessui/vue": "^1.7.23",
    "@heroicons/vue": "^2.2.0",
    "@hugerte/hugerte-vue": "^2.0.2",
    "dompurify": "^3.2.6",
    "hugerte": "^1.0.9",
    "pinia": "^3.0.3",
    "vue": "^3.5.18",
    "vue-router": "^4.5.1",
    "vuedraggable": "^4"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4.1.13",
    "@tailwindcss/vite": "^4.1.13",
    "@vitejs/plugin-vue": "^6.0.1",
    "autoprefixer": "^10.4.21",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.13",
    "vite": "^7.1.2"
  }
}


===== END FILE =====


===== BEGIN FILE: web\public\vite.svg =====

<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

===== END FILE =====


===== BEGIN FILE: web\README.md =====

# Vue 3 + Vite

This template should help get you started developing with Vue 3 in Vite. The template uses Vue 3 `<script setup>` SFCs, check out the [script setup docs](https://v3.vuejs.org/api/sfc-script-setup.html#sfc-script-setup) to learn more.

Learn more about IDE Support for Vue in the [Vue Docs Scaling up Guide](https://vuejs.org/guide/scaling-up/tooling.html#ide-support).


===== END FILE =====


===== BEGIN FILE: web\src\App.vue =====

<template>
    <div class="min-h-screen bg-gray-50 text-gray-900">
        <header class="bg-gray-900 text-white">
            <nav class="mx-auto max-w-5xl px-4 py-3 flex items-center justify-between">
                <RouterLink to="/" class="font-semibold tracking-wide">Task Manager</RouterLink>
                <div class="flex gap-4 items-center">
                    <RouterLink to="/" class="hover:text-emerald-300">Home</RouterLink>
                    <RouterLink to="/board" class="hover:text-emerald-300">Board</RouterLink>
                    <span v-if="auth.isAuthed" class="font-medium text-emerald-300">
                        {{ auth.user?.name }}
                    </span>
                    <RouterLink v-else to="/login" class="hover:text-emerald-300">Login</RouterLink>
                </div>
            </nav>
        </header>
        <main class="mx-auto max-w-5xl px-4 py-6">
            <RouterView />
        </main>
    </div>
</template>

<script setup>
import { useAuth } from "./stores/auth";
const auth = useAuth();
</script>


===== END FILE =====


===== BEGIN FILE: web\src\assets\vue.svg =====

<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="37.07" height="36" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 198"><path fill="#41B883" d="M204.8 0H256L128 220.8L0 0h97.92L128 51.2L157.44 0h47.36Z"></path><path fill="#41B883" d="m0 0l128 220.8L256 0h-51.2L128 132.48L50.56 0H0Z"></path><path fill="#35495E" d="M50.56 0L128 133.12L204.8 0h-47.36L128 51.2L97.92 0H50.56Z"></path></svg>

===== END FILE =====


===== BEGIN FILE: web\src\components\HelloWorld.vue =====

<script setup>
import { ref } from 'vue'

defineProps({
  msg: String,
})

const count = ref(0)
</script>

<template>
  <h1>{{ msg }}</h1>

  <div class="card">
    <button type="button" @click="count++">count is {{ count }}</button>
    <p>
      Edit
      <code>components/HelloWorld.vue</code> to test HMR
    </p>
  </div>

  <p>
    Check out
    <a href="https://vuejs.org/guide/quick-start.html#local" target="_blank"
      >create-vue</a
    >, the official Vue + Vite starter
  </p>
  <p>
    Learn more about IDE Support for Vue in the
    <a
      href="https://vuejs.org/guide/scaling-up/tooling.html#ide-support"
      target="_blank"
      >Vue Docs Scaling up Guide</a
    >.
  </p>
  <p class="read-the-docs">Click on the Vite and Vue logos to learn more</p>
</template>

<style scoped>
.read-the-docs {
  color: #888;
}
</style>


===== END FILE =====


===== BEGIN FILE: web\src\components\RichEditor.vue =====

<template>
    <Editor v-model="inner" :init="init" @blur="emitUpdate" />
</template>

<script setup>
import { ref, watch } from "vue";
import Editor from "@hugerte/hugerte-vue"; // official Vue wrapper (default export) :contentReference[oaicite:1]{index=1}

/* ===== HugeRTE bundling (per docs) ===== */
// IMPORTANT: the default export must be imported before other HugeRTE imports
import hugerte from "hugerte"; // global must come first
import "hugerte/models/dom"; // DOM model
import "hugerte/icons/default"; // icons
import "hugerte/themes/silver"; // theme
// skins + content CSS (so the editor actually renders styled)
import "hugerte/skins/ui/oxide/skin.js";
import "hugerte/skins/ui/oxide/content.js";
import "hugerte/skins/content/default/content.js";
// plugins you use (paste is core—don't import it)
import "hugerte/plugins/lists";
import "hugerte/plugins/link";
import "hugerte/plugins/image";
import "hugerte/plugins/code";
/* ======================================= */
// Docs show this exact bundling approach + the need to set skin_url/content_css="default". :contentReference[oaicite:2]{index=2}

const props = defineProps({ modelValue: { type: String, default: "" }, height: { type: Number, default: 280 } });
const emit = defineEmits(["update:modelValue"]);
const inner = ref(props.modelValue);

watch(inner, () => emit("update:modelValue", inner.value || ""), { flush: "post" });

watch(
    () => props.modelValue,
    (v) => {
        if (v !== inner.value) inner.value = v;
    }
);
function emitUpdate() {
    emit("update:modelValue", inner.value || "");
}

// Upload handler to your /api/uploads endpoint (reuses your CSRF/cookies)
async function images_upload_handler(blobInfo) {
    const fd = new FormData();
    fd.append("file", blobInfo.blob(), blobInfo.filename());
    const m = document.cookie.match(/(?:^|;\s*)csrf=([^;]+)/);
    const csrf = m ? decodeURIComponent(m[1]) : "";
    const res = await fetch("/api/uploads", {
        method: "POST",
        credentials: "include",
        headers: csrf ? { "X-CSRF-Token": csrf } : {},
        body: fd,
    });
    if (!res.ok) throw new Error("upload failed");
    const json = await res.json();

    const absUrl = json.url.startsWith("http") ? json.url : new URL(json.url, window.location.origin).toString();
    return absUrl;
}

const init = {
    height: props.height,
    menubar: false,
    // DO NOT list "paste" (it’s core in Tiny6/HugeRTE; listing it makes the loader look for a plugin file)
    plugins: "lists link image code",
    toolbar: "undo redo | bold italic underline | bullist numlist | link image | code",
    paste_data_images: true,
    automatic_uploads: true,
    images_upload_handler,
    // tell HugeRTE to use the bundled skin/content we imported above
    skin_url: "default",
    content_css: "default",
    branding: false,
    // optional: keep URLs as-is for your /uploads paths
    convert_urls: false,
};

// needed to keep tree-shakers happy; reference prevents import elision
void hugerte;
</script>


===== END FILE =====


===== BEGIN FILE: web\src\components\SafeHtml.vue =====

<template>
    <div v-html="clean" />
</template>

<script setup>
import { computed } from "vue";
import DOMPurify from "dompurify";

const props = defineProps({
    html: { type: String, default: "" },
});

// Make it reactive + allow basic tags/attrs (incl. <img src>)
const options = {
    ALLOWED_TAGS: [
        "p",
        "br",
        "strong",
        "b",
        "em",
        "i",
        "u",
        "ul",
        "ol",
        "li",
        "a",
        "img",
        "code",
        "pre",
        "span",
        "div",
        "h1",
        "h2",
        "h3",
        "blockquote",
    ],
    ALLOWED_ATTR: ["href", "target", "rel", "src", "alt", "title", "class"],
    ALLOW_DATA_ATTR: true, // allow data-* if present
};

const clean = computed(() => DOMPurify.sanitize(props.html || "", options));
</script>


===== END FILE =====


===== BEGIN FILE: web\src\components\TaskModal.vue =====

<!-- TaskModal.vue -->
<template>
    <div v-if="open" class="fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black/40" @click="$emit('close')"></div>

        <div class="relative w-full max-w-2xl rounded-2xl bg-white p-5 shadow-xl">
            <!-- Header -->
            <div class="mb-4 flex items-center justify-between">
                <h3 class="text-lg font-semibold">
                    {{ mode === "create" ? "Create task" : isEditing ? "Edit task" : "Task details" }}
                </h3>
                <div class="flex items-center gap-2">
                    <!-- Create mode actions -->
                    <template v-if="mode === 'create'">
                        <button class="rounded px-2 py-1 text-sm hover:bg-gray-100" @click="$emit('close')">
                            Cancel
                        </button>
                        <button
                            :disabled="saving || !formTitle"
                            class="rounded bg-gray-900 px-3 py-1.5 text-sm text-white hover:bg-gray-800 disabled:opacity-60"
                            @click="createTask"
                        >
                            <span v-if="saving">Saving…</span><span v-else>Save</span>
                        </button>
                    </template>

                    <!-- Editing actions -->
                    <template v-else-if="isEditing">
                        <button class="rounded px-2 py-1 text-sm hover:bg-gray-100" @click="isEditing = false">
                            Cancel
                        </button>
                        <button
                            :disabled="!editTitle"
                            class="rounded bg-emerald-600 px-3 py-1.5 text-sm text-white hover:bg-emerald-500 disabled:opacity-60"
                            @click="saveEdit"
                        >
                            Save
                        </button>
                    </template>

                    <!-- View mode actions -->
                    <template v-else>
                        <button class="rounded px-2 py-1 text-sm hover:bg-gray-100" @click="startEdit">Edit</button>
                        <button
                            class="rounded bg-red-600 px-3 py-1.5 text-sm text-white hover:bg-red-500"
                            @click="removeTask"
                        >
                            Delete
                        </button>
                    </template>

                    <!-- Close (always) -->
                    <button class="rounded px-2 py-1 text-sm hover:bg-gray-100" @click="$emit('close')">✕</button>
                </div>
            </div>

            <!-- Body -->

            <!-- CREATE -->
            <div v-if="mode === 'create'" class="space-y-3">
                <label class="block text-sm font-medium">Title</label>
                <input
                    v-model.trim="formTitle"
                    class="w-full rounded-md border border-gray-300 px-3 py-2 focus:ring-2 focus:ring-emerald-400"
                    placeholder="Short summary"
                    autofocus
                />

                <label class="block text-sm font-medium">Description</label>
                <RichEditor :key="editorKey" v-model="formDesc" />
            </div>

            <!-- NOT CREATE: either EDIT or VIEW -->
            <div v-else>
                <!-- EDIT -->
                <div v-if="isEditing" class="space-y-3">
                    <label class="block text-sm font-medium">Title</label>
                    <input
                        v-model.trim="editTitle"
                        class="w-full rounded-md border border-gray-300 px-3 py-2 focus:ring-2 focus:ring-emerald-400"
                        placeholder="Task title"
                        autofocus
                    />

                    <label class="block text-sm font-medium">Description</label>
                    <RichEditor v-model="editDesc" />
                </div>

                <!-- VIEW -->
                <div v-else class="space-y-5">
                    <div>
                        <div class="flex items-start justify-between">
                            <div>
                                <div class="text-xl font-semibold">{{ task?.title }}</div>
                                <div class="mt-2 prose max-w-none">
                                    <SafeHtml :html="task?.description || ''" />
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Comments -->
                    <div class="border-t pt-4">
                        <div class="mb-2 text-sm font-medium text-gray-700">Comments</div>

                        <!-- Collapsed composer (Trello-style) -->
                        <button
                            v-if="!composerOpen"
                            class="w-full rounded-xl border px-4 py-3 text-left text-gray-500 hover:bg-gray-50"
                            @click="openComposer"
                        >
                            Write a comment…
                        </button>

                        <!-- Expanded rich composer -->
                        <div v-else class="space-y-2">
                            <RichEditor v-model="commentHtml" />
                            <div class="flex items-center gap-2">
                                <button
                                    :disabled="savingComment || !hasCommentContent"
                                    class="rounded bg-gray-900 px-3 py-1.5 text-sm text-white hover:bg-gray-800 disabled:opacity-60"
                                    @click="saveComment"
                                >
                                    {{ savingComment ? "Saving…" : "Save" }}
                                </button>
                                <button class="rounded px-2 py-1 text-sm hover:bg-gray-100" @click="cancelComment">
                                    Cancel
                                </button>
                            </div>
                        </div>

                        <!-- Comments list -->
                        <div v-if="loadingComments" class="mt-3 text-sm text-gray-500">Loading…</div>
                        <div v-else class="mt-3 max-h-60 overflow-y-auto pr-1">
                            <ul class="space-y-2">
                                <li v-for="c in comments" :key="c.id" class="rounded border bg-white p-2 text-sm">
                                    <div class="text-gray-800">
                                        <SafeHtml :html="c.body || ''" />
                                    </div>
                                    <div class="mt-1 text-xs text-gray-500">
                                        {{ new Date(c.created_at).toLocaleString() }}
                                    </div>
                                </li>
                                <li v-if="!comments.length" class="text-sm text-gray-500">No comments yet.</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <!-- /NOT CREATE -->
        </div>
    </div>
</template>

<script setup>
import { ref, watch, computed, nextTick } from "vue";
import { api } from "../lib/api";
import RichEditor from "./RichEditor.vue";
import SafeHtml from "./SafeHtml.vue";

const props = defineProps({
    open: { type: Boolean, default: false },
    mode: { type: String, default: "create" }, // 'create' | 'view'
    listId: { type: String, default: "" }, // used in create mode
    task: { type: Object, default: null }, // used in view mode
});

const emit = defineEmits(["close", "created", "commented", "updated", "deleted"]);

// --- create mode state
const formTitle = ref("");
const formDesc = ref("");
const saving = ref(false);
const editorKey = ref("editor-boot");

// --- view mode / comments state
const comments = ref([]);
const loadingComments = ref(false);

// New Trello-style composer state
const composerOpen = ref(false);
const commentHtml = ref("");
const savingComment = ref(false);

const hasCommentContent = computed(() => {
    const html = (commentHtml.value || "").replace(/<br\s*\/?>/gi, "\n");
    const text = html
        .replace(/<[^>]+>/g, "")
        .replace(/&nbsp;/g, " ")
        .trim();
    return text.length > 0;
});

// --- edit mode state
const isEditing = ref(false);
const editTitle = ref("");
const editDesc = ref("");

function initForm() {
    if (props.mode === "create") {
        formTitle.value = "";
        formDesc.value = "";
    } else if (props.task) {
        formTitle.value = props.task.title || "";
        formDesc.value = props.task.description || "";
    }
    // force remount RichEditor so it doesn't keep stale content
    editorKey.value = `${props.task?.id || "new"}-${Date.now()}`;
}

watch(
    () => props.open,
    (o) => {
        if (o) initForm();
    }
);
watch(
    () => props.mode,
    () => initForm(),
    { immediate: true }
);
watch(
    () => props.task?.id,
    () => initForm()
);

// load comments when opening in view mode
watch(
    () => [props.open, props.mode, props.task?.id],
    async ([open, mode]) => {
        if (!open || mode !== "view" || !props.task?.id) return;
        loadingComments.value = true;
        try {
            comments.value = await api.get(`/api/comments?task_id=${encodeURIComponent(props.task.id)}`);
        } catch (e) {
            console.error(e);
        } finally {
            loadingComments.value = false;
        }
    }
);

// also reset edit/composer state on open/close
watch(
    () => props.open,
    (o) => {
        if (o) {
            isEditing.value = false;
            composerOpen.value = false;
            commentHtml.value = "";
        } else {
            isEditing.value = false;
            composerOpen.value = false;
            commentHtml.value = "";
        }
    }
);

// ----- create task
async function createTask() {
    if (!formTitle.value.trim() || !props.listId) return;
    saving.value = true;
    try {
        const payload = {
            list_id: props.listId,
            title: formTitle.value.trim(),
            description: formDesc.value || "",
        };
        const res = await api.post("/api/tasks", payload);
        emit("created", { ...res, description: formDesc.value || "" });
        emit("close");
    } catch (e) {
        alert(e?.message || "Create failed");
    } finally {
        saving.value = false;
    }
}

// ----- comments (Trello-style)
function openComposer() {
    composerOpen.value = true;
    nextTick(() => {
        // editor will autofocus caret itself; no-op here
    });
}
function cancelComment() {
    composerOpen.value = false;
    commentHtml.value = "";
}
async function saveComment() {
    const body = commentHtml.value || "";
    if (!props.task?.id || !hasCommentContent.value) return;
    savingComment.value = true;
    try {
        const c = await api.post("/api/comments", { task_id: props.task.id, body });
        comments.value.unshift(c);
        commentHtml.value = "";
        composerOpen.value = false;
        emit("commented", c); // let Board bump comment_count if it wants
    } catch (e) {
        alert(e?.message || "Failed to comment");
    } finally {
        savingComment.value = false;
    }
}

// ----- edit task
function startEdit() {
    if (!props.task) return;
    isEditing.value = true;
    editTitle.value = props.task.title || "";
    editDesc.value = props.task.description || "";
}
async function saveEdit() {
    if (!props.task?.id) return;
    try {
        const payload = { title: editTitle.value, description: editDesc.value };
        const res = await api.patch(`/api/tasks?id=${encodeURIComponent(props.task.id)}`, payload);
        emit("updated", res);
        isEditing.value = false;
        emit("close");
    } catch (e) {
        alert(e?.message || "Failed to update task");
    }
}
async function removeTask() {
    if (!props.task?.id) return;
    if (!confirm("Are you sure you want to delete this task?")) return;
    try {
        await api.del(`/api/tasks?id=${encodeURIComponent(props.task.id)}`);
        emit("deleted", props.task.id);
        emit("close");
    } catch (e) {
        alert(e?.message || "Failed to delete task");
    }
}
</script>

<style scoped>
/* Small UX helpers */
</style>


===== END FILE =====


===== BEGIN FILE: web\src\lib\api.js =====

// web/src/lib/api.js
function getCookie(name) {
    return (
        document.cookie
            .split("; ")
            .find((row) => row.startsWith(name + "="))
            ?.split("=")[1] ?? ""
    );
}

async function request(path, { method = "GET", headers = {}, body } = {}) {
    const isMutation = !["GET", "HEAD"].includes(method.toUpperCase());
    const finalHeaders = new Headers(headers);
    finalHeaders.set("Accept", "application/json");

    // JSON body for mutations unless caller sets something else
    let payload = body;
    if (isMutation && body && !(body instanceof FormData)) {
        finalHeaders.set("Content-Type", "application/json");
        payload = JSON.stringify(body);
    }

    // CSRF for mutations if present
    if (isMutation) {
        const csrf = getCookie("csrf");
        if (csrf) finalHeaders.set("X-CSRF-Token", csrf);
    }

    const res = await fetch(path, {
        method,
        headers: finalHeaders,
        body: payload,
        credentials: "include", // send cookies (sid/csrf)
    });

    // Try to parse JSON if server says it's JSON
    const ctype = res.headers.get("content-type") || "";
    const looksJson = ctype.toLowerCase().startsWith("application/json");
    const data = looksJson ? await res.json().catch(() => null) : await res.text();

    if (!res.ok) {
        const msg = (data && data.error) || (typeof data === "string" ? data : "") || `HTTP ${res.status}`;
        const err = new Error(msg);
        err.status = res.status;
        err.data = data;
        throw err;
    }
    return data;
}

export const api = {
    get: (path, opts = {}) => request(path, { ...opts, method: "GET" }),
    post: (path, body, opts = {}) => request(path, { ...opts, method: "POST", body }),
    put: (path, body, opts = {}) => request(path, { ...opts, method: "PUT", body }),
    patch: (path, body, opts = {}) => request(path, { ...opts, method: "PATCH", body }),
    del: (path, opts = {}) => request(path, { ...opts, method: "DELETE" }),
};


===== END FILE =====


===== BEGIN FILE: web\src\main.js =====

import { createApp } from "vue";
import { createPinia } from "pinia";
import router from "./router";
import "./style.css";
import App from "./App.vue";
import { api } from "./lib/api";
import { useAuth } from "./stores/auth";

if (import.meta.env.DEV) {
    // dev convenience
    // eslint-disable-next-line no-undef
    window.api = api;
}

const app = createApp(App);
const pinia = createPinia();
app.use(pinia);
app.use(router);

// 🔐 Try to restore user session on first load
useAuth(pinia)
    .fetchMe()
    .catch(() => {
        /* not logged in is fine */
    });

app.mount("#app");


===== END FILE =====


===== BEGIN FILE: web\src\router.js =====

// web/src/router.js
import { createRouter, createWebHistory } from "vue-router";
import Home from "./views/Home.vue";

export default createRouter({
    history: createWebHistory(),
    routes: [
        { path: "/", name: "home", component: Home },
        { path: "/login", name: "login", component: () => import("./views/Login.vue") },
        { path: "/board", name: "board", component: () => import("./views/Board.vue") },
        { path: "/register", name: "register", component: () => import("./views/Register.vue") },
    ],
});


===== END FILE =====


===== BEGIN FILE: web\src\stores\auth.js =====

import { defineStore } from "pinia";
import { api } from "../lib/api";

export const useAuth = defineStore("auth", {
    state: () => ({ user: null, loading: false, error: "" }),
    getters: { isAuthed: (s) => !!s.user },
    actions: {
        async fetchMe() {
            this.loading = true;
            this.error = "";
            try {
                const me = await api.get("/api/me");
                this.user = me;
                return me;
            } catch (e) {
                if (e?.status === 401) this.user = null;
                else this.error = e?.message || "Failed to load user";
                throw e;
            } finally {
                this.loading = false;
            }
        },
        async login(email, password) {
            this.loading = true;
            this.error = "";
            try {
                await api.post("/api/login", { email, password });
                await this.fetchMe();
            } catch (e) {
                this.error = e?.message || "Login failed";
                throw e;
            } finally {
                this.loading = false;
            }
        },
        clientLogout() {
            this.user = null;
            this.error = "";
        },
    },
});


===== END FILE =====


===== BEGIN FILE: web\src\style.css =====

@import "tailwindcss";


===== END FILE =====


===== BEGIN FILE: web\src\views\Board.vue =====

<!-- Board.vue -->
<template>
    <div class="mx-auto max-w-7xl p-6">
        <div class="mb-4 flex items-center gap-3">
            <h1 class="text-2xl font-semibold">Board</h1>
            <button
                @click="loadBoard"
                :disabled="loading"
                class="rounded-md bg-gray-900 px-3 py-1.5 text-sm font-medium text-white hover:bg-gray-800 disabled:opacity-60"
            >
                {{ loading ? "Loading…" : "Refresh" }}
            </button>
            <div v-if="error" class="rounded-md border border-red-200 bg-red-50 px-3 py-2 text-sm text-red-700">
                <span v-if="error.toLowerCase().includes('unauthorized')">
                    You need to log in to view boards.
                    <RouterLink to="/login" class="underline">Go to Login</RouterLink>
                </span>
                <span v-else>{{ error }}</span>
            </div>
        </div>

        <div v-if="board" class="space-y-2">
            <h2 class="text-lg font-medium text-gray-700">{{ board.name }}</h2>

            <!-- Lists grid -->
            <div class="flex gap-4 overflow-x-auto pb-2">
                <div
                    v-for="l in board.lists"
                    :key="l.id"
                    class="w-72 shrink-0 rounded-lg border border-gray-200 bg-white"
                >
                    <div class="border-b border-gray-200 px-4 py-2">
                        <div class="flex items-center justify-between">
                            <span class="font-medium">{{ l.name }}</span>
                            <span class="text-xs text-gray-500">pos {{ l.position }}</span>
                        </div>
                    </div>

                    <ul class="space-y-2 p-3">
                        <li
                            v-for="t in l.tasks"
                            :key="t.id"
                            class="rounded-md border border-emerald-200 bg-emerald-50 p-3 cursor-pointer hover:bg-emerald-100"
                            @click="openTask(t)"
                        >
                            <div class="flex items-center justify-between">
                                <span class="font-medium">{{ t.title }}</span>
                                <span class="text-xs uppercase tracking-wide text-gray-600">{{ t.status }}</span>
                            </div>
                            <div class="mt-2 flex items-center gap-3 text-sm text-gray-600">
                                +
                                <span class="flex items-center gap-1">
                                    <ChatBubbleLeftIcon class="h-4 w-4 text-gray-500" /> {{ t.comment_count }}
                                </span>
                                <span class="flex items-center gap-1">
                                    <UserIcon class="h-4 w-4 text-gray-500" /> x{{ t.assignees?.length || 0 }}
                                </span>
                                <span class="ml-auto text-xs text-gray-400">pos {{ t.position }}</span>
                            </div>
                        </li>
                        <li v-if="!l.tasks?.length" class="px-3 py-2 text-sm text-gray-500">No tasks</li>
                    </ul>
                    <button
                        class="m-3 mt-1 w-[calc(100%-1.5rem)] rounded-md border border-dashed border-gray-300 py-2 text-sm text-gray-600 hover:border-gray-400 hover:bg-white"
                        @click="openCreate(l.id)"
                    >
                        + Add task
                    </button>
                </div>
            </div>
        </div>

        <p v-else class="text-gray-600">No board loaded yet.</p>
    </div>

    <TaskModal
        :open="showModal"
        :mode="modalMode"
        :listId="targetListId"
        :task="activeTask"
        @close="showModal = false"
        @created="onCreated"
        @commented="onCommented"
        @updated="onUpdated"
        @deleted="onDeleted"
    />
</template>

<script setup>
import { ref, watchEffect } from "vue";
import { useRoute } from "vue-router";
import { api } from "../lib/api";
import { ChatBubbleLeftIcon, UserIcon } from "@heroicons/vue/24/outline";
import TaskModal from "../components/TaskModal.vue";

const route = useRoute();
const loading = ref(false);
const error = ref("");

// Keep board reactive; null is fine initially, we replace with server payload
const board = ref(null);

// --- load board (first by default, or ?id=...)
async function loadBoard() {
    loading.value = true;
    error.value = "";
    try {
        const id = route.query.id;
        const url = id ? `/api/boards?id=${encodeURIComponent(id)}` : "/api/boards";
        board.value = await api.get(url);
    } catch (e) {
        error.value = e?.message || "Failed to load board";
    } finally {
        loading.value = false;
    }
}

// auto-load on mount and when ?id changes
watchEffect(() => {
    // dependency track
    route.query.id;
    loadBoard();
});

// ----- Modal orchestration -----
const showModal = ref(false);
const modalMode = ref("create"); // "create" | "view"
const targetListId = ref(""); // used for create
const activeTask = ref(null); // keep a REFERENCE to the task in board.lists

function openCreate(listId) {
    modalMode.value = "create";
    targetListId.value = listId;
    activeTask.value = null;
    showModal.value = true;
}

function openTask(task) {
    // IMPORTANT: keep reference, do NOT clone
    console.log("[Board] openTask:", { id: task.id, title: task.title, hasDescription: !!task.description });
    modalMode.value = "view";
    activeTask.value = task;
    targetListId.value = "";
    showModal.value = true;
}

// ----- Events from TaskModal -----

// When TaskModal creates a task, append it to the right list (reactively)
function onCreated(res) {
    console.log("[Board] onCreated:", res);
    if (!board.value?.lists?.length) return;
    const list =
        board.value.lists.find((l) => l.id === res.list_id) ||
        board.value.lists.find((l) => l.id === targetListId.value);
    if (!list) return;
    if (!Array.isArray(list.tasks)) list.tasks = [];
    list.tasks.push({
        id: res.id,
        list_id: res.list_id,
        title: res.title,
        description: res.description || "",
        status: res.status,
        position: res.position,
        assignees: res.assignees ?? [],
        comment_count: 0,
    });
}

// When a comment is posted in TaskModal, bump the card’s comment_count
function onCommented(c) {
    const taskId = activeTask.value?.id ?? c.task_id;
    if (!taskId || !board.value?.lists?.length) return;
    for (const list of board.value.lists) {
        const card = list.tasks?.find((t) => t.id === taskId);
        if (card) {
            card.comment_count = (card.comment_count || 0) + 1;
            break;
        }
    }
}

// PATCH result → update the task in-place using splice to preserve reactivity
function onUpdated(updated) {
    console.log("[Board] onUpdated:", updated);
    if (!updated?.id || !board.value?.lists?.length) return;
    for (const list of board.value.lists) {
        const idx = list.tasks?.findIndex((t) => t.id === updated.id) ?? -1;
        if (idx !== -1) {
            const prev = list.tasks[idx];
            // replace via splice to trigger reactivity
            list.tasks.splice(idx, 1, {
                ...prev, // keep fields not returned by PATCH (assignees, comment_count, list_id)
                title: updated.title ?? prev.title,
                description: updated.description ?? prev.description,
                status: updated.status ?? prev.status,
                position: typeof updated.position === "number" ? updated.position : prev.position,
            });
            break;
        }
    }
}

// DELETE result → remove the task reactively
function onDeleted(taskId) {
    console.log("[Board] onDeleted:", taskId);
    if (!taskId || !board.value?.lists?.length) return;
    for (const list of board.value.lists) {
        const idx = list.tasks?.findIndex((t) => t.id === taskId) ?? -1;
        if (idx !== -1) {
            list.tasks.splice(idx, 1);
            break;
        }
    }
}
</script>

<style scoped></style>


===== END FILE =====


===== BEGIN FILE: web\src\views\Home.vue =====

<template>
    <div class="space-y-4">
        <h1 class="text-2xl font-semibold">Welcome</h1>

        <div v-if="auth.isAuthed" class="flex items-center gap-3">
            <span class="text-gray-700"
                >Signed in as <strong>{{ auth.user?.name }}</strong></span
            >
            <button @click="onLogout" class="rounded-md bg-gray-900 px-3 py-1.5 text-white hover:bg-gray-800">
                Logout
            </button>
        </div>

        <div v-else>
            <RouterLink to="/login" class="underline">Login</RouterLink>
            <span class="mx-1">·</span>
            <RouterLink to="/register" class="underline">Register</RouterLink>
        </div>
    </div>
</template>

<script setup>
import { useRouter } from "vue-router";
import { useAuth } from "../stores/auth";
import { api } from "../lib/api";

const router = useRouter();
const auth = useAuth();

async function onLogout() {
    try {
        await api.post("/api/logout", {}); // clears cookies server-side
    } catch (_) {}
    // reset client state
    auth.$reset?.(); // if defined; otherwise:
    auth.user = null;
    auth.isAuthed = false;
    router.push("/login");
}
</script>


===== END FILE =====


===== BEGIN FILE: web\src\views\Login.vue =====

<template>
    <div class="mx-auto max-w-sm py-10">
        <h1 class="mb-6 text-2xl font-semibold">Login</h1>

        <form @submit.prevent="onSubmit" class="space-y-4">
            <div>
                <label class="mb-1 block text-sm font-medium">Email</label>
                <input
                    v-model.trim="email"
                    type="email"
                    required
                    class="w-full rounded-md border border-gray-300 bg-white px-3 py-2 outline-none focus:ring-2 focus:ring-emerald-400"
                    placeholder="you@example.com"
                />
            </div>

            <div>
                <label class="mb-1 block text-sm font-medium">Password</label>
                <input
                    v-model="password"
                    type="password"
                    required
                    class="w-full rounded-md border border-gray-300 bg-white px-3 py-2 outline-none focus:ring-2 focus:ring-emerald-400"
                    placeholder="••••••••"
                />
            </div>

            <button
                type="submit"
                :disabled="auth.loading"
                class="w-full rounded-md bg-gray-900 px-4 py-2 font-medium text-white hover:bg-gray-800 disabled:opacity-60"
            >
                <span v-if="auth.loading">Signing in…</span>
                <span v-else>Sign in</span>
            </button>

            <p v-if="auth.error" class="text-sm text-red-600">{{ auth.error }}</p>
        </form>

        <p class="mt-6 text-sm text-gray-600">
            Don’t have an account?
            <RouterLink to="/register" class="underline">Register</RouterLink>
        </p>
    </div>
</template>

<script setup>
import { ref } from "vue";
import { useRouter } from "vue-router";
import { useAuth } from "../stores/auth";

const email = ref("");
const password = ref("");
const auth = useAuth();
const router = useRouter();

async function onSubmit() {
    try {
        await auth.login(email.value, password.value);
        router.push("/");
    } catch {
        /* error shown by store */
    }
}
</script>

<style scoped></style>


===== END FILE =====


===== BEGIN FILE: web\src\views\Register.vue =====

<template>
    <div class="mx-auto max-w-sm py-10">
        <h1 class="mb-6 text-2xl font-semibold">Register</h1>

        <form @submit.prevent="onSubmit" class="space-y-4">
            <div>
                <label class="mb-1 block text-sm font-medium">Name</label>
                <input
                    v-model.trim="name"
                    required
                    class="w-full rounded-md border border-gray-300 bg-white px-3 py-2 outline-none focus:ring-2 focus:ring-emerald-400"
                />
            </div>

            <div>
                <label class="mb-1 block text-sm font-medium">Email</label>
                <input
                    v-model.trim="email"
                    type="email"
                    required
                    class="w-full rounded-md border border-gray-300 bg-white px-3 py-2 outline-none focus:ring-2 focus:ring-emerald-400"
                />
            </div>

            <div>
                <label class="mb-1 block text-sm font-medium">Password</label>
                <input
                    v-model="password"
                    type="password"
                    required
                    class="w-full rounded-md border border-gray-300 bg-white px-3 py-2 outline-none focus:ring-2 focus:ring-emerald-400"
                />
            </div>

            <button
                type="submit"
                :disabled="loading"
                class="w-full rounded-md bg-gray-900 px-4 py-2 font-medium text-white hover:bg-gray-800 disabled:opacity-60"
            >
                <span v-if="loading">Creating account…</span>
                <span v-else>Register</span>
            </button>

            <p v-if="error" class="text-sm text-red-600">{{ error }}</p>
        </form>

        <p class="mt-6 text-sm text-gray-600">
            Already have an account?
            <RouterLink to="/login" class="underline">Login</RouterLink>
        </p>
    </div>
</template>

<script setup>
import { ref } from "vue";
import { useRouter } from "vue-router";
import { api } from "../lib/api";

const name = ref("");
const email = ref("");
const password = ref("");
const loading = ref(false);
const error = ref("");
const router = useRouter();

async function onSubmit() {
    loading.value = true;
    error.value = "";
    try {
        await api.post("/api/register", { name: name.value, email: email.value, password: password.value });
        await api.post("/api/login", { email: email.value, password: password.value });
        router.push("/board");
    } catch (e) {
        error.value = e?.message || "Registration failed";
    } finally {
        loading.value = false;
    }
}
</script>


===== END FILE =====


===== BEGIN FILE: web\vite.config.js =====

// vite.config.js
import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";
import tailwindcss from "@tailwindcss/vite";

export default defineConfig({
    plugins: [vue(), tailwindcss()],
    server: {
        host: true,
        port: 5173,
        strictPort: true,
        hmr: {
            host: "localhost",
            clientPort: 5173,
            protocol: "ws",
        },
        watch: {
            usePolling: true,
            interval: 300,
        },
        proxy: {
            "/api": { target: "http://api:8080", changeOrigin: true },
            "/uploads": { target: "http://api:8080", changeOrigin: true }, // ← required
        },
    },
});


===== END FILE =====



===== END FILE =====


===== BEGIN FILE: README.md =====

# Task Manager

Mono-repo with Go API, Vue 3 web app, and Postgres (via Docker).

## Structure
- **server/** � Go backend (API, auth, tasks, comments)
- **web/** � Vue 3 frontend (Vite, Pinia, Router)
- **db/migrations/** � SQL migrations (golang-migrate)
- **docker/** � Dockerfiles / scripts
- **docker-compose.yml** � (later) dev stack runner

## Dev Targets (MVP)
- Auth: register/login/logout
- Tasks: CRUD, assign, status, due date
- Comments: per task
- Filters/search

## Next Steps
1) Skeleton now.
2) Prereqs: Docker Desktop, Go, Node LTS.
3) Docker Compose for dev (db/api/web).
4) Minimal health endpoints.
## DB Quick Access
- pgAdmin: http://localhost:5050  
  - Add Server ? Host: db, User: app, Password: app


===== END FILE =====


===== BEGIN FILE: server\.air.toml =====

root = "."
tmp_dir = "tmp"
poll = true
poll_interval = 1000
[build]
cmd = "go build -o ./tmp/api ./cmd/api"
bin = "./tmp/api"
include_ext = ["go"]
exclude_dir = ["tmp","vendor"]
delay = 1000


===== END FILE =====


===== BEGIN FILE: server\cmd\api\handlers_auth.go =====

package main

import (
	"crypto/rand"
	"database/sql"
	"encoding/base64"
	"encoding/json"
	"log"
	"net/http"
	"strings"
	"sync"
	"time"

	"golang.org/x/crypto/argon2"
)

// ---- password hashing ----

func hashPassword(pw string) (string, error) {
	salt := make([]byte, 16)
	if _, err := rand.Read(salt); err != nil {
		return "", err
	}
	const (
		timeCost    = 3
		memoryCost  = 64 * 1024
		parallelism = 1
		keyLen      = 32
	)
	dk := argon2.IDKey([]byte(pw), salt, timeCost, memoryCost, uint8(parallelism), keyLen)
	return "$argon2id$v=19$m=65536,t=3,p=1$" +
		base64.RawStdEncoding.EncodeToString(salt) + "$" +
		base64.RawStdEncoding.EncodeToString(dk), nil
}

func verifyPassword(pw, encoded string) bool {
	parts := strings.Split(encoded, "$")
	if len(parts) != 6 || parts[1] != "argon2id" {
		return false
	}
	salt, err1 := base64.RawStdEncoding.DecodeString(parts[4])
	want, err2 := base64.RawStdEncoding.DecodeString(parts[5])
	if err1 != nil || err2 != nil {
		return false
	}
	dk := argon2.IDKey([]byte(pw), salt, 3, 64*1024, 1, uint32(len(want)))
	if len(dk) != len(want) {
		return false
	}
	var v byte
	for i := range dk {
		v |= dk[i] ^ want[i]
	}
	return v == 0
}

// ---- session store (dev-only) ----

type Session struct {
	UserID  string
	CSRF    string
	Expires time.Time
}

var (
	sessions   = make(map[string]Session)
	sessionsMu sync.Mutex
)

func randToken(n int) string {
	b := make([]byte, n)
	_, _ = rand.Read(b)
	return base64.RawURLEncoding.EncodeToString(b) // URL-safe
}

// ---- /api/register ----

type registerReq struct {
	Email    string `json:"email"`
	Name     string `json:"name"`
	Password string `json:"password"`
}
type registerResp struct {
	ID    string `json:"id"`
	Email string `json:"email"`
	Name  string `json:"name"`
}

func registerHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	var req registerReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "bad json", http.StatusBadRequest)
		return
	}
	if req.Email == "" || req.Password == "" || req.Name == "" {
		http.Error(w, "missing fields", http.StatusBadRequest)
		return
	}
	h, err := hashPassword(req.Password)
	if err != nil {
		http.Error(w, "hashing failed", http.StatusInternalServerError)
		return
	}
	var id string
	err = db.QueryRow(
		`INSERT INTO users (email, password_hash, name) VALUES ($1,$2,$3) RETURNING id`,
		req.Email, h, req.Name,
	).Scan(&id)
	if err != nil {
		http.Error(w, "could not create user", http.StatusConflict)
		return
	}

	// 👇 best-effort provisioning (workspace + default board + lists)
	if err := provisionPersonalWorkspace(db, id, req.Name); err != nil {
		// Non-fatal for registration; just log it. User can still log in.
		log.Println("provisioning failed:", err)
	}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(registerResp{ID: id, Email: req.Email, Name: req.Name})
}

func provisionPersonalWorkspace(db *sql.DB, userID, userName string) error {
	tx, err := db.Begin()
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			_ = tx.Rollback()
		}
	}()

	// 1) workspace (slug NULL for now; keep it simple)
	var wsID string
	if err = tx.QueryRow(
		`INSERT INTO workspaces (name, slug) VALUES ($1, NULL) RETURNING id`,
		userName+"'s Workspace",
	).Scan(&wsID); err != nil {
		return err
	}

	// 2) membership (owner)
	if _, err = tx.Exec(
		`INSERT INTO workspace_members (workspace_id, user_id, role) VALUES ($1,$2,'owner')
         ON CONFLICT DO NOTHING`,
		wsID, userID,
	); err != nil {
		return err
	}

	// 3) default board
	var boardID string
	if err = tx.QueryRow(
		`INSERT INTO boards (name, owner_id, workspace_id) VALUES ($1,$2,$3) RETURNING id`,
		"My Board", userID, wsID,
	).Scan(&boardID); err != nil {
		return err
	}

	// 4) three starter lists
	if _, err = tx.Exec(
		`INSERT INTO lists (board_id, name, position)
         VALUES ($1,'To Do',0), ($1,'In Progress',1), ($1,'Done',2)`,
		boardID,
	); err != nil {
		return err
	}

	// 4.1) three example tasks in "To Do"
	var todoListID string
	if err = tx.QueryRow(
		`SELECT id FROM lists WHERE board_id=$1 AND name='To Do' LIMIT 1`,
		boardID,
	).Scan(&todoListID); err != nil {
		return err
	}
	if _, err = tx.Exec(
		`INSERT INTO tasks (list_id, title, description, position, status, created_by)
         VALUES
         ($1, 'Welcome to your board', 'Drag cards between lists as work progresses.', 0, 'todo', $2),
         ($1, 'Create your first task', 'Click + to add tasks. Assign teammates later.', 1, 'todo', $2),
         ($1, 'Invite a teammate', 'Collaborate by inviting others to your workspace.', 2, 'todo', $2)`,
		todoListID, userID,
	); err != nil {
		return err
	}

	return tx.Commit()
}

// ---- /api/login ----

type loginReq struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}
type loginResp struct {
	UserID string `json:"user_id"`
}

func loginHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	var req loginReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "bad json", http.StatusBadRequest)
		return
	}
	if req.Email == "" || req.Password == "" {
		http.Error(w, "missing fields", http.StatusBadRequest)
		return
	}
	var userID, pwHash string
	err := db.QueryRow(`SELECT id, password_hash FROM users WHERE email=$1`, req.Email).Scan(&userID, &pwHash)
	if err == sql.ErrNoRows {
		http.Error(w, "invalid credentials", http.StatusUnauthorized)
		return
	} else if err != nil {
		http.Error(w, "login failed", http.StatusInternalServerError)
		return
	}
	if !verifyPassword(req.Password, pwHash) {
		http.Error(w, "invalid credentials", http.StatusUnauthorized)
		return
	}
	sid := randToken(24)
	csrf := randToken(24)
	sessionsMu.Lock()
	sessions[sid] = Session{UserID: userID, CSRF: csrf, Expires: time.Now().Add(24 * time.Hour)}
	sessionsMu.Unlock()

	http.SetCookie(w, &http.Cookie{
		Name:     "sid",
		Value:    sid,
		Path:     "/",
		HttpOnly: true,
		SameSite: http.SameSiteLaxMode,
	})
	http.SetCookie(w, &http.Cookie{
		Name:     "csrf",
		Value:    csrf,
		Path:     "/",
		HttpOnly: false,
		SameSite: http.SameSiteLaxMode,
	})
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(loginResp{UserID: userID})
}

// ---- /api/me ----

type meResp struct {
	ID    string `json:"id"`
	Email string `json:"email"`
	Name  string `json:"name"`
}

func getSessionFromRequest(r *http.Request) (Session, bool) {
	c, err := r.Cookie("sid")
	if err != nil || c.Value == "" {
		return Session{}, false
	}
	sessionsMu.Lock()
	s, ok := sessions[c.Value]
	sessionsMu.Unlock()
	if !ok || time.Now().After(s.Expires) {
		return Session{}, false
	}
	return s, true
}

func meHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	if r.Method != http.MethodGet {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	sess, ok := getSessionFromRequest(r)
	if !ok {
		http.Error(w, "unauthorized", http.StatusUnauthorized)
		return
	}
	var email, name string
	if err := db.QueryRow(`SELECT email, name FROM users WHERE id=$1`, sess.UserID).Scan(&email, &name); err != nil {
		http.Error(w, "user not found", http.StatusUnauthorized)
		return
	}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(meResp{ID: sess.UserID, Email: email, Name: name})
}

// ---- CSRF helper for POST/PUT/PATCH/DELETE ----

func requireAuthAndCSRF(w http.ResponseWriter, r *http.Request) (Session, bool) {
	s, ok := getSessionFromRequest(r)
	if !ok {
		http.Error(w, "unauthorized", http.StatusUnauthorized)
		return Session{}, false
	}
	token := r.Header.Get("X-CSRF-Token")
	if token == "" || token != s.CSRF {
		http.Error(w, "forbidden", http.StatusForbidden)
		return Session{}, false
	}
	return s, true
}

func logoutHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Best-effort: remove session by cookie value
	if sid, ok := readSIDCookie(r); ok {
		deleteSessionByID(sid)
	}

	// Expire cookies
	http.SetCookie(w, &http.Cookie{
		Name:     "sid",
		Value:    "",
		Path:     "/",
		HttpOnly: true,
		SameSite: http.SameSiteLaxMode,
		MaxAge:   -1,
	})
	http.SetCookie(w, &http.Cookie{
		Name:     "csrf",
		Value:    "",
		Path:     "/",
		SameSite: http.SameSiteLaxMode,
		MaxAge:   -1,
	})

	w.Header().Set("Content-Type", "application/json")
	_, _ = w.Write([]byte(`{"ok":true}`))
}

// readSIDCookie extracts the session id from the "sid" cookie.
func readSIDCookie(r *http.Request) (string, bool) {
	c, err := r.Cookie("sid")
	if err != nil || c.Value == "" {
		return "", false
	}
	return c.Value, true
}

// deleteSessionByID removes a session from the in-memory store.
// Relies on the existing `sessions` map and `sessionsMu` mutex defined above.
func deleteSessionByID(sid string) {
	sessionsMu.Lock()
	defer sessionsMu.Unlock()
	delete(sessions, sid)
}


===== END FILE =====


===== BEGIN FILE: server\cmd\api\handlers_board.go =====

package main

import (
	"database/sql"
	"encoding/json"
	"net/http"
)

// ---- DTOs for board payload ----

type BoardDTO struct {
	ID    string    `json:"id"`
	Name  string    `json:"name"`
	Lists []ListDTO `json:"lists"`
}

type ListDTO struct {
	ID       string    `json:"id"`
	Name     string    `json:"name"`
	Position int       `json:"position"`
	Tasks    []TaskDTO `json:"tasks"`
}

type TaskDTO struct {
	ID           string   `json:"id"`
	Title        string   `json:"title"`
	Description  string   `json:"description"`
	Status       string   `json:"status"`
	Position     int      `json:"position"`
	Assignees    []string `json:"assignees"`
	CommentCount int      `json:"comment_count"`
}

// ---- Handler ----

func boardsHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	// 🔐 now requires auth (so we can scope by workspace membership)
	sess, ok := getSessionFromRequest(r)
	if !ok {
		http.Error(w, "unauthorized", http.StatusUnauthorized)
		return
	}

	qid := r.URL.Query().Get("id")
	inc := r.URL.Query().Get("include")

	var wantLists, wantTasks bool
	switch inc {
	case "", "lists,tasks":
		wantLists, wantTasks = true, true
	case "lists":
		wantLists, wantTasks = true, false
	default:
		wantLists, wantTasks = false, false
	}

	// 1) board (scoped to user's workspace membership)
	var boardID, boardName string
	var err error
	if qid != "" {
		err = db.QueryRow(`
            SELECT b.id, b.name
            FROM boards b
            JOIN workspace_members m ON m.workspace_id = b.workspace_id
            WHERE m.user_id = $1 AND b.id = $2
        `, sess.UserID, qid).Scan(&boardID, &boardName)
		if err == sql.ErrNoRows {
			http.Error(w, "board not found", http.StatusNotFound)
			return
		} else if err != nil {
			http.Error(w, "board query failed", http.StatusInternalServerError)
			return
		}
	} else {
		err = db.QueryRow(`
            SELECT b.id, b.name
            FROM boards b
            JOIN workspace_members m ON m.workspace_id = b.workspace_id
            WHERE m.user_id = $1
            ORDER BY b.created_at ASC
            LIMIT 1
        `, sess.UserID).Scan(&boardID, &boardName)
		if err == sql.ErrNoRows {
			http.Error(w, "no board found", http.StatusNotFound)
			return
		} else if err != nil {
			http.Error(w, "board query failed", http.StatusInternalServerError)
			return
		}
	}

	// 2) lists
	lists := make([]ListDTO, 0)
	if wantLists {
		rows, err := db.Query(`SELECT id, name, position FROM lists WHERE board_id=$1 ORDER BY position ASC`, boardID)
		if err != nil {
			http.Error(w, "lists query failed", http.StatusInternalServerError)
			return
		}
		defer rows.Close()

		for rows.Next() {
			var l ListDTO
			if err := rows.Scan(&l.ID, &l.Name, &l.Position); err == nil {
				l.Tasks = make([]TaskDTO, 0) // non-nil slice
				lists = append(lists, l)
			}
		}
	}

	// 3) tasks per list
	if wantTasks {
		for i := range lists {
			trows, err := db.Query(`SELECT id, title, description, status, position FROM tasks WHERE list_id=$1 ORDER BY position ASC`, lists[i].ID)
			if err != nil {
				http.Error(w, "tasks query failed", http.StatusInternalServerError)
				return
			}
			tasks := make([]TaskDTO, 0)
			for trows.Next() {
				var t TaskDTO
				if err := trows.Scan(&t.ID, &t.Title, &t.Description, &t.Status, &t.Position); err == nil {
					// assignees
					arows, _ := db.Query(`SELECT user_id FROM task_assignees WHERE task_id=$1`, t.ID)
					aids := make([]string, 0)
					for arows.Next() {
						var uid string
						if err := arows.Scan(&uid); err == nil {
							aids = append(aids, uid)
						}
					}
					arows.Close()
					t.Assignees = aids

					// comment count
					_ = db.QueryRow(`SELECT COUNT(*) FROM comments WHERE task_id=$1`, t.ID).Scan(&t.CommentCount)

					tasks = append(tasks, t)
				}
			}
			trows.Close()
			lists[i].Tasks = tasks
		}
	}

	// 4) respond
	payload := BoardDTO{ID: boardID, Name: boardName, Lists: lists}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(payload)
}


===== END FILE =====


===== BEGIN FILE: server\cmd\api\handlers_comments.go =====

package main

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"strings"
	"time"
)

// ---- DTOs ----
type createCommentReq struct {
	TaskID string `json:"task_id"`
	Body   string `json:"body"`
}
type commentResp struct {
	ID        string    `json:"id"`
	TaskID    string    `json:"task_id"`
	AuthorID  string    `json:"author_id"`
	Body      string    `json:"body"`
	CreatedAt time.Time `json:"created_at"`
}
type commentItem struct {
	ID        string    `json:"id"`
	TaskID    string    `json:"task_id"`
	AuthorID  string    `json:"author_id"`
	Body      string    `json:"body"`
	CreatedAt time.Time `json:"created_at"`
}

// ---- POST /api/comments (auth + CSRF) ----
func createCommentHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	sess, ok := requireAuthAndCSRF(w, r)
	if !ok {
		return
	}

	var req createCommentReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil || req.TaskID == "" || strings.TrimSpace(req.Body) == "" {
		http.Error(w, "bad json", http.StatusBadRequest)
		return
	}

	var id string
	var created time.Time
	if err := db.QueryRow(
		`INSERT INTO comments (task_id, author_id, body) VALUES ($1,$2,$3) RETURNING id, created_at`,
		req.TaskID, sess.UserID, req.Body,
	).Scan(&id, &created); err != nil {
		http.Error(w, "insert failed", http.StatusBadRequest)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(commentResp{
		ID: id, TaskID: req.TaskID, AuthorID: sess.UserID, Body: req.Body, CreatedAt: created,
	})
}

// ---- GET /api/comments?task_id=... (public) ----
func listCommentsHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	if r.Method != http.MethodGet {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	taskID := r.URL.Query().Get("task_id")
	if taskID == "" {
		http.Error(w, "missing task_id", http.StatusBadRequest)
		return
	}
	rows, err := db.Query(`
		SELECT id, task_id, author_id, body, created_at
		FROM comments
		WHERE task_id = $1
		ORDER BY created_at ASC
	`, taskID)
	if err != nil {
		http.Error(w, "query failed", http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	items := make([]commentItem, 0)
	for rows.Next() {
		var c commentItem
		if err := rows.Scan(&c.ID, &c.TaskID, &c.AuthorID, &c.Body, &c.CreatedAt); err == nil {
			items = append(items, c)
		}
	}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(items)
}


===== END FILE =====


===== BEGIN FILE: server\cmd\api\handlers_lists.go =====

// handlers_lists.go
package main

import (
	"database/sql"
	"encoding/json"
	"net/http"
)

// POST /api/lists/reorder
// Body: { "board_id": "...", "list_ids": ["id1","id2",...] }
type reorderListsReq struct {
	BoardID string   `json:"board_id"`
	ListIDs []string `json:"list_ids"`
}

func reorderListsHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	sess, ok := requireAuthAndCSRF(w, r)
	if !ok {
		return
	}

	var req reorderListsReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil || req.BoardID == "" || len(req.ListIDs) == 0 {
		http.Error(w, "bad json", http.StatusBadRequest)
		return
	}

	// ACL: user must be a member of the workspace that owns this board
	var allowed bool
	if err := db.QueryRow(`
		SELECT EXISTS (
		  SELECT 1
		  FROM boards b
		  JOIN workspace_members m ON m.workspace_id = b.workspace_id
		  WHERE b.id = $1 AND m.user_id = $2
		)
	`, req.BoardID, sess.UserID).Scan(&allowed); err != nil || !allowed {
		http.Error(w, "forbidden", http.StatusForbidden)
		return
	}

	tx, err := db.Begin()
	if err != nil {
		http.Error(w, "tx begin failed", http.StatusInternalServerError)
		return
	}
	defer func() { _ = tx.Rollback() }()

	// Ensure all provided lists belong to this board (cheap guard)
	for _, id := range req.ListIDs {
		var ok bool
		if err := tx.QueryRow(`SELECT EXISTS(SELECT 1 FROM lists WHERE id=$1 AND board_id=$2)`, id, req.BoardID).Scan(&ok); err != nil || !ok {
			http.Error(w, "list not in board", http.StatusBadRequest)
			return
		}
	}

	// Update positions 0..n-1 in the given order
	for i, id := range req.ListIDs {
		if _, err := tx.Exec(`UPDATE lists SET position=$1 WHERE id=$2 AND board_id=$3`, i, id, req.BoardID); err != nil {
			http.Error(w, "update failed", http.StatusBadRequest)
			return
		}
	}

	if err := tx.Commit(); err != nil {
		http.Error(w, "commit failed", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	_, _ = w.Write([]byte(`{"ok":true}`))
}


===== END FILE =====


===== BEGIN FILE: server\cmd\api\handlers_tasks.go =====

// handlers_tasks.go
package main

import (
	"database/sql"
	"encoding/json"
	"log"
	"net/http"
	"strconv"
	"strings"
)

type createTaskReq struct {
	ListID      string `json:"list_id"`
	Title       string `json:"title"`
	Description string `json:"description,omitempty"`
}

type taskCreatedResp struct {
	ID          string `json:"id"`
	ListID      string `json:"list_id"`
	Title       string `json:"title"`
	Description string `json:"description"`
	Position    int    `json:"position"`
	Status      string `json:"status"`
}

func createTaskHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	sess, ok := requireAuthAndCSRF(w, r) // reuse helper
	if !ok {
		return
	}

	var req createTaskReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "bad json", http.StatusBadRequest)
		return
	}
	req.Title = strings.TrimSpace(req.Title)
	if req.ListID == "" || req.Title == "" {
		http.Error(w, "missing fields", http.StatusBadRequest)
		return
	}

	// Ensure the list belongs to a board in a workspace the user is a member of
	var valid bool
	if err := db.QueryRow(`
		SELECT EXISTS(
		  SELECT 1
		  FROM lists l
		  JOIN boards b ON b.id = l.board_id
		  JOIN workspace_members m ON m.workspace_id = b.workspace_id
		  WHERE l.id = $1 AND m.user_id = $2
		)
	`, req.ListID, sess.UserID).Scan(&valid); err != nil || !valid {
		http.Error(w, "forbidden", http.StatusForbidden)
		return
	}

	// Next position in the list
	var nextPos int
	_ = db.QueryRow(`SELECT COALESCE(MAX(position)+1, 0) FROM tasks WHERE list_id=$1`, req.ListID).Scan(&nextPos)

	// Insert
	var id, status string
	if err := db.QueryRow(`
		INSERT INTO tasks (list_id, title, description, position, status, created_by)
		VALUES ($1,$2,$3,$4,'todo',$5)
		RETURNING id, status
	`, req.ListID, req.Title, req.Description, nextPos, sess.UserID).Scan(&id, &status); err != nil {
		http.Error(w, "insert failed", http.StatusBadRequest)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(taskCreatedResp{
		ID: id, ListID: req.ListID, Title: req.Title, Position: nextPos, Status: status,
	})
}

type updateTaskReq struct {
	Title       *string `json:"title,omitempty"`
	Description *string `json:"description,omitempty"`
}

func updateTaskHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	sess, ok := requireAuthAndCSRF(w, r)
	if !ok {
		return
	}

	id := r.URL.Query().Get("id")
	if id == "" {
		http.Error(w, "missing id", http.StatusBadRequest)
		return
	}

	var req updateTaskReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "bad json", http.StatusBadRequest)
		return
	}

	// Build dynamic SET clause with correct $1, $2, ...
	sets := []string{}
	args := []any{}

	if req.Title != nil {
		sets = append(sets, "title=$"+strconv.Itoa(len(args)+1))
		args = append(args, strings.TrimSpace(*req.Title))
	}
	if req.Description != nil {
		sets = append(sets, "description=$"+strconv.Itoa(len(args)+1))
		args = append(args, *req.Description)
	}
	if len(sets) == 0 {
		http.Error(w, "nothing to update", http.StatusBadRequest)
		return
	}

	// WHERE placeholders come after SET args
	//  ... id is next
	args = append(args, id)
	idPos := len(args) // position of id we just appended

	//  ... user id is after that
	args = append(args, sess.UserID)
	userPos := len(args)

	query := `
		UPDATE tasks t
		SET ` + strings.Join(sets, ", ") + `, updated_at=NOW()
		WHERE t.id=$` + strconv.Itoa(idPos) + `
		AND EXISTS (
			SELECT 1
			FROM lists l
			JOIN boards b ON b.id = l.board_id
			JOIN workspace_members m ON m.workspace_id = b.workspace_id
			WHERE l.id = t.list_id AND m.user_id = $` + strconv.Itoa(userPos) + `
		)
		RETURNING t.id, t.title, t.description, t.status, t.position
	`

	log.Printf("[updateTaskHandler] query OK:\n%s\nargs: %#v", query, args)

	var out taskCreatedResp
	// taskCreatedResp now includes Description (you already added it)
	if err := db.QueryRow(query, args...).Scan(&out.ID, &out.Title, &out.Description, &out.Status, &out.Position); err != nil {
		http.Error(w, "update failed", http.StatusBadRequest)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(out)
}

func deleteTaskHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	sess, ok := requireAuthAndCSRF(w, r)
	if !ok {
		return
	}

	id := r.URL.Query().Get("id")
	if id == "" {
		http.Error(w, "missing id", http.StatusBadRequest)
		return
	}

	res, err := db.Exec(`
        DELETE FROM tasks t
        WHERE t.id=$1
        AND EXISTS (
            SELECT 1
            FROM lists l
            JOIN boards b ON b.id=l.board_id
            JOIN workspace_members m ON m.workspace_id=b.workspace_id
            WHERE l.id=t.list_id AND m.user_id=$2
        )
    `, id, sess.UserID)
	if err != nil {
		http.Error(w, "delete failed", http.StatusBadRequest)
		return
	}
	n, _ := res.RowsAffected()
	if n == 0 {
		http.Error(w, "not found or forbidden", http.StatusNotFound)
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

// POST /api/tasks/reorder
// Body: { "task_id": "...", "to_list_id": "...", "to_index": 0 }
type reorderOrMoveReq struct {
	TaskID   string `json:"task_id"`
	ToListID string `json:"to_list_id"`
	ToIndex  int    `json:"to_index"`
}

type reorderOrMoveResp struct {
	ID       string `json:"id"`
	ListID   string `json:"list_id"`
	Position int    `json:"position"`
}

func reorderOrMoveTaskHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	sess, ok := requireAuthAndCSRF(w, r)
	if !ok {
		return
	}

	var req reorderOrMoveReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil || req.TaskID == "" || req.ToListID == "" {
		http.Error(w, "bad json", http.StatusBadRequest)
		return
	}

	tx, err := db.Begin()
	if err != nil {
		http.Error(w, "tx begin failed", http.StatusInternalServerError)
		return
	}
	defer func() { _ = tx.Rollback() }()

	// Current location
	var srcListID string
	var oldPos int
	if err := tx.QueryRow(`SELECT list_id, position FROM tasks WHERE id=$1`, req.TaskID).Scan(&srcListID, &oldPos); err == sql.ErrNoRows {
		http.Error(w, "task not found", http.StatusNotFound)
		return
	} else if err != nil {
		http.Error(w, "lookup failed", http.StatusInternalServerError)
		return
	}

	// ACL: user must belong to src & dest workspaces
	var okSrc, okDst bool
	if err := tx.QueryRow(`
		SELECT EXISTS(
		  SELECT 1 FROM lists l
		  JOIN boards b ON b.id = l.board_id
		  JOIN workspace_members m ON m.workspace_id = b.workspace_id
		  WHERE l.id=$1 AND m.user_id=$2
		)`, srcListID, sess.UserID).Scan(&okSrc); err != nil || !okSrc {
		http.Error(w, "forbidden", http.StatusForbidden)
		return
	}
	if err := tx.QueryRow(`
		SELECT EXISTS(
		  SELECT 1 FROM lists l
		  JOIN boards b ON b.id = l.board_id
		  JOIN workspace_members m ON m.workspace_id = b.workspace_id
		  WHERE l.id=$1 AND m.user_id=$2
		)`, req.ToListID, sess.UserID).Scan(&okDst); err != nil || !okDst {
		http.Error(w, "forbidden", http.StatusForbidden)
		return
	}

	// Clamp index to valid bounds in destination
	var destCount int
	if err := tx.QueryRow(`SELECT COUNT(*) FROM tasks WHERE list_id=$1`, req.ToListID).Scan(&destCount); err != nil {
		http.Error(w, "count dest failed", http.StatusInternalServerError)
		return
	}
	toIndex := req.ToIndex
	if toIndex < 0 {
		toIndex = 0
	}
	if srcListID == req.ToListID {
		if toIndex >= destCount {
			toIndex = max(0, destCount-1)
		}
	} else {
		// when moving across lists, inserting at the end is allowed (== destCount)
		if toIndex > destCount {
			toIndex = destCount
		}
	}

	// Same-list reorder: shift neighbors then set the task
	if srcListID == req.ToListID {
		if toIndex != oldPos {
			if toIndex < oldPos {
				// task moves up → push down the block [toIndex..oldPos-1]
				if _, err := tx.Exec(`
					UPDATE tasks SET position = position + 1
					WHERE list_id = $1 AND position >= $2 AND position < $3
				`, srcListID, toIndex, oldPos); err != nil {
					http.Error(w, "shift up block failed", http.StatusBadRequest)
					return
				}
			} else {
				// task moves down → pull up the block [oldPos+1..toIndex]
				if _, err := tx.Exec(`
					UPDATE tasks SET position = position - 1
					WHERE list_id = $1 AND position > $2 AND position <= $3
				`, srcListID, oldPos, toIndex); err != nil {
					http.Error(w, "shift down block failed", http.StatusBadRequest)
					return
				}
			}
			if _, err := tx.Exec(`UPDATE tasks SET position=$1, updated_at=NOW() WHERE id=$2`, toIndex, req.TaskID); err != nil {
				http.Error(w, "update pos failed", http.StatusBadRequest)
				return
			}
		}
	} else {
		// Cross-list: compact source, make room in dest, then move
		if _, err := tx.Exec(`
			UPDATE tasks SET position = position - 1
			WHERE list_id = $1 AND position > $2
		`, srcListID, oldPos); err != nil {
			http.Error(w, "compact source failed", http.StatusBadRequest)
			return
		}
		if _, err := tx.Exec(`
			UPDATE tasks SET position = position + 1
			WHERE list_id = $1 AND position >= $2
		`, req.ToListID, toIndex); err != nil {
			http.Error(w, "make room dest failed", http.StatusBadRequest)
			return
		}
		if _, err := tx.Exec(`
			UPDATE tasks SET list_id=$1, position=$2, updated_at=NOW() WHERE id=$3
		`, req.ToListID, toIndex, req.TaskID); err != nil {
			http.Error(w, "move failed", http.StatusBadRequest)
			return
		}
	}

	if err := tx.Commit(); err != nil {
		http.Error(w, "commit failed", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(reorderOrMoveResp{
		ID: req.TaskID, ListID: req.ToListID, Position: toIndex,
	})
}

// tiny helper
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}


===== END FILE =====


===== BEGIN FILE: server\cmd\api\handlers_uploads.go =====

package main

import (
	"encoding/json"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"time"
)

var uploadDir = "/app/server/uploads" // absolute path inside the api container

func uploadHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	if err := r.ParseMultipartForm(20 << 20); err != nil {
		http.Error(w, "bad multipart", http.StatusBadRequest)
		return
	}
	file, hdr, err := r.FormFile("file")
	if err != nil {
		http.Error(w, "file missing", http.StatusBadRequest)
		return
	}
	defer file.Close()

	_ = os.MkdirAll(uploadDir, 0o755)

	ext := filepath.Ext(hdr.Filename)
	if ext == "" {
		ext = ".bin"
	}
	name := time.Now().UTC().Format("20060102-150405.000000000") + ext
	dstPath := filepath.Join(uploadDir, name)

	dst, err := os.Create(dstPath)
	if err != nil {
		http.Error(w, "cannot save", http.StatusInternalServerError)
		return
	}
	defer dst.Close()
	if _, err = io.Copy(dst, file); err != nil {
		http.Error(w, "write error", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(map[string]string{
		"url": "/uploads/" + name, // path we serve below
	})
}


===== END FILE =====


===== BEGIN FILE: server\cmd\api\main.go =====

package main

import (
	"database/sql"
	"log"
	"net/http"
	"os"

	_ "github.com/jackc/pgx/v5/stdlib"
)

func main() {
	dsn := os.Getenv("DB_DSN")
	if dsn == "" {
		log.Fatal("DB_DSN not set")
	}

	db, err := sql.Open("pgx", dsn)
	if err != nil {
		log.Fatal("cannot open db:", err)
	}
	defer db.Close()

	if err := db.Ping(); err != nil {
		log.Fatal("cannot ping db:", err)
	}
	log.Println("DB OK")

	var version string
	if err := db.QueryRow("select version()").Scan(&version); err != nil {
		log.Fatal("db query failed:", err)
	}
	log.Println("DB version:", version)

	registerRoutes(db)

	log.Println("API listening on :8080 (with DB)")
	log.Fatal(http.ListenAndServe(":8080", nil))

}


===== END FILE =====


===== BEGIN FILE: server\cmd\api\routes.go =====

// routes.go
package main

import (
	"database/sql"
	"net/http"
)

func registerRoutes(db *sql.DB) {
	http.HandleFunc("/api/boards", func(w http.ResponseWriter, r *http.Request) {
		boardsHandler(w, r, db)
	})
	http.HandleFunc("/api/register", func(w http.ResponseWriter, r *http.Request) {
		registerHandler(w, r, db)
	})
	http.HandleFunc("/api/login", func(w http.ResponseWriter, r *http.Request) {
		loginHandler(w, r, db)
	})
	http.HandleFunc("/api/me", func(w http.ResponseWriter, r *http.Request) {
		meHandler(w, r, db)
	})
	http.HandleFunc("/api/comments", func(w http.ResponseWriter, r *http.Request) {
		switch r.Method {
		case http.MethodGet:
			listCommentsHandler(w, r, db)
		case http.MethodPost:
			createCommentHandler(w, r, db)
		default:
			http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		}
	})
	http.HandleFunc("/api/tasks", func(w http.ResponseWriter, r *http.Request) {
		switch r.Method {
		case http.MethodPost:
			createTaskHandler(w, r, db)
		case http.MethodPatch:
			updateTaskHandler(w, r, db)
		case http.MethodDelete:
			deleteTaskHandler(w, r, db)
		default:
			http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		}
	})
	http.HandleFunc("/api/tasks/reorder", func(w http.ResponseWriter, r *http.Request) {
		reorderOrMoveTaskHandler(w, r, db)
	})
	http.HandleFunc("/api/lists/reorder", func(w http.ResponseWriter, r *http.Request) {
		reorderListsHandler(w, r, db)
	})
	http.HandleFunc("/api/logout", logoutHandler)
	http.HandleFunc("/api/uploads", uploadHandler)
	http.Handle("/uploads/", http.StripPrefix("/uploads/", http.FileServer(http.Dir(uploadDir))))
}


===== END FILE =====


===== BEGIN FILE: server\Dockerfile =====

# syntax=docker/dockerfile:1
FROM golang:1.25

# Install Air for hot reload
RUN go install github.com/air-verse/air@latest

WORKDIR /app


===== END FILE =====


===== BEGIN FILE: server\go.mod =====

module github.com/ri5pekt/task-manager/server

go 1.25.1

require (
	github.com/jackc/pgx/v5 v5.7.6
	golang.org/x/crypto v0.37.0
)

require (
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect
	github.com/jackc/puddle/v2 v2.2.2 // indirect
	golang.org/x/sync v0.13.0 // indirect
	golang.org/x/sys v0.32.0 // indirect
	golang.org/x/text v0.24.0 // indirect
)


===== END FILE =====


===== BEGIN FILE: web\.env =====

VITE_TINYMCE_API_KEY=78uxnmz8kwnwy75u8b0umcxff4z6tmj3aku9gcoopeb9lfv4

===== END FILE =====


===== BEGIN FILE: web\.gitignore =====

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files

.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
.pnpm-store/
.vscode/


# Dev artifacts
cookies.txt
server/tmp/
project_snapshot_*.txt

# Tailwind v4 (using @tailwindcss/vite, no PostCSS config)
web/postcss.config.js

===== END FILE =====


===== BEGIN FILE: web\Dockerfile =====

# syntax=docker/dockerfile:1
# Placeholder for Vue app image. We�ll add build steps later.
FROM node:20 AS dev
WORKDIR /app
# (deps, dev server, and prod build will be added later)


===== END FILE =====


===== BEGIN FILE: web\index.html =====

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + Vue</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>


===== END FILE =====


===== BEGIN FILE: web\package.json =====

{
  "name": "web",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@headlessui/vue": "^1.7.23",
    "@heroicons/vue": "^2.2.0",
    "@hugerte/hugerte-vue": "^2.0.2",
    "dompurify": "^3.2.6",
    "hugerte": "^1.0.9",
    "pinia": "^3.0.3",
    "vue": "^3.5.18",
    "vue-router": "^4.5.1",
    "vuedraggable": "^4.1.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4.1.13",
    "@tailwindcss/vite": "^4.1.13",
    "@vitejs/plugin-vue": "^6.0.1",
    "autoprefixer": "^10.4.21",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.13",
    "vite": "^7.1.2"
  }
}


===== END FILE =====


===== BEGIN FILE: web\public\vite.svg =====

<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

===== END FILE =====


===== BEGIN FILE: web\README.md =====

# Vue 3 + Vite

This template should help get you started developing with Vue 3 in Vite. The template uses Vue 3 `<script setup>` SFCs, check out the [script setup docs](https://v3.vuejs.org/api/sfc-script-setup.html#sfc-script-setup) to learn more.

Learn more about IDE Support for Vue in the [Vue Docs Scaling up Guide](https://vuejs.org/guide/scaling-up/tooling.html#ide-support).


===== END FILE =====


===== BEGIN FILE: web\src\App.vue =====

<template>
    <div class="min-h-screen bg-gray-50 text-gray-900">
        <header class="bg-gray-900 text-white">
            <nav class="mx-auto max-w-5xl px-4 py-3 flex items-center justify-between">
                <RouterLink to="/" class="font-semibold tracking-wide">Task Manager</RouterLink>
                <div class="flex gap-4 items-center">
                    <RouterLink to="/" class="hover:text-emerald-300">Home</RouterLink>
                    <RouterLink to="/board" class="hover:text-emerald-300">Board</RouterLink>
                    <span v-if="auth.isAuthed" class="font-medium text-emerald-300">
                        {{ auth.user?.name }}
                    </span>
                    <RouterLink v-else to="/login" class="hover:text-emerald-300">Login</RouterLink>
                </div>
            </nav>
        </header>
        <main class="mx-auto max-w-5xl px-4 py-6">
            <RouterView />
        </main>
    </div>
</template>

<script setup>
import { useAuth } from "./stores/auth";
const auth = useAuth();
</script>


===== END FILE =====


===== BEGIN FILE: web\src\assets\vue.svg =====

<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="37.07" height="36" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 198"><path fill="#41B883" d="M204.8 0H256L128 220.8L0 0h97.92L128 51.2L157.44 0h47.36Z"></path><path fill="#41B883" d="m0 0l128 220.8L256 0h-51.2L128 132.48L50.56 0H0Z"></path><path fill="#35495E" d="M50.56 0L128 133.12L204.8 0h-47.36L128 51.2L97.92 0H50.56Z"></path></svg>

===== END FILE =====


===== BEGIN FILE: web\src\components\HelloWorld.vue =====

<script setup>
import { ref } from 'vue'

defineProps({
  msg: String,
})

const count = ref(0)
</script>

<template>
  <h1>{{ msg }}</h1>

  <div class="card">
    <button type="button" @click="count++">count is {{ count }}</button>
    <p>
      Edit
      <code>components/HelloWorld.vue</code> to test HMR
    </p>
  </div>

  <p>
    Check out
    <a href="https://vuejs.org/guide/quick-start.html#local" target="_blank"
      >create-vue</a
    >, the official Vue + Vite starter
  </p>
  <p>
    Learn more about IDE Support for Vue in the
    <a
      href="https://vuejs.org/guide/scaling-up/tooling.html#ide-support"
      target="_blank"
      >Vue Docs Scaling up Guide</a
    >.
  </p>
  <p class="read-the-docs">Click on the Vite and Vue logos to learn more</p>
</template>

<style scoped>
.read-the-docs {
  color: #888;
}
</style>


===== END FILE =====


===== BEGIN FILE: web\src\components\RichEditor.vue =====

<template>
    <Editor v-model="inner" :init="init" @blur="emitUpdate" />
</template>

<script setup>
import { ref, watch } from "vue";
import Editor from "@hugerte/hugerte-vue"; // official Vue wrapper (default export) :contentReference[oaicite:1]{index=1}

/* ===== HugeRTE bundling (per docs) ===== */
// IMPORTANT: the default export must be imported before other HugeRTE imports
import hugerte from "hugerte"; // global must come first
import "hugerte/models/dom"; // DOM model
import "hugerte/icons/default"; // icons
import "hugerte/themes/silver"; // theme
// skins + content CSS (so the editor actually renders styled)
import "hugerte/skins/ui/oxide/skin.js";
import "hugerte/skins/ui/oxide/content.js";
import "hugerte/skins/content/default/content.js";
// plugins you use (paste is core—don't import it)
import "hugerte/plugins/lists";
import "hugerte/plugins/link";
import "hugerte/plugins/image";
import "hugerte/plugins/code";
/* ======================================= */
// Docs show this exact bundling approach + the need to set skin_url/content_css="default". :contentReference[oaicite:2]{index=2}

const props = defineProps({ modelValue: { type: String, default: "" }, height: { type: Number, default: 280 } });
const emit = defineEmits(["update:modelValue"]);
const inner = ref(props.modelValue);

watch(inner, () => emit("update:modelValue", inner.value || ""), { flush: "post" });

watch(
    () => props.modelValue,
    (v) => {
        if (v !== inner.value) inner.value = v;
    }
);
function emitUpdate() {
    emit("update:modelValue", inner.value || "");
}

// Upload handler to your /api/uploads endpoint (reuses your CSRF/cookies)
async function images_upload_handler(blobInfo) {
    const fd = new FormData();
    fd.append("file", blobInfo.blob(), blobInfo.filename());
    const m = document.cookie.match(/(?:^|;\s*)csrf=([^;]+)/);
    const csrf = m ? decodeURIComponent(m[1]) : "";
    const res = await fetch("/api/uploads", {
        method: "POST",
        credentials: "include",
        headers: csrf ? { "X-CSRF-Token": csrf } : {},
        body: fd,
    });
    if (!res.ok) throw new Error("upload failed");
    const json = await res.json();

    const absUrl = json.url.startsWith("http") ? json.url : new URL(json.url, window.location.origin).toString();
    return absUrl;
}

const init = {
    height: props.height,
    menubar: false,
    // DO NOT list "paste" (it’s core in Tiny6/HugeRTE; listing it makes the loader look for a plugin file)
    plugins: "lists link image code",
    toolbar: "undo redo | bold italic underline | bullist numlist | link image | code",
    paste_data_images: true,
    automatic_uploads: true,
    images_upload_handler,
    // tell HugeRTE to use the bundled skin/content we imported above
    skin_url: "default",
    content_css: "default",
    branding: false,
    // optional: keep URLs as-is for your /uploads paths
    convert_urls: false,
};

// needed to keep tree-shakers happy; reference prevents import elision
void hugerte;
</script>


===== END FILE =====


===== BEGIN FILE: web\src\components\SafeHtml.vue =====

<template>
    <div v-html="clean" />
</template>

<script setup>
import { computed } from "vue";
import DOMPurify from "dompurify";

const props = defineProps({
    html: { type: String, default: "" },
});

// Make it reactive + allow basic tags/attrs (incl. <img src>)
const options = {
    ALLOWED_TAGS: [
        "p",
        "br",
        "strong",
        "b",
        "em",
        "i",
        "u",
        "ul",
        "ol",
        "li",
        "a",
        "img",
        "code",
        "pre",
        "span",
        "div",
        "h1",
        "h2",
        "h3",
        "blockquote",
    ],
    ALLOWED_ATTR: ["href", "target", "rel", "src", "alt", "title", "class"],
    ALLOW_DATA_ATTR: true, // allow data-* if present
};

const clean = computed(() => DOMPurify.sanitize(props.html || "", options));
</script>


===== END FILE =====


===== BEGIN FILE: web\src\components\TaskModal.vue =====

<!-- TaskModal.vue -->
<template>
    <div v-if="open" class="fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black/40" @click="$emit('close')"></div>

        <div class="relative w-full max-w-2xl rounded-2xl bg-white p-5 shadow-xl">
            <!-- Header -->
            <div class="mb-4 flex items-center justify-between">
                <h3 class="text-lg font-semibold">
                    {{ mode === "create" ? "Create task" : isEditing ? "Edit task" : "Task details" }}
                </h3>
                <div class="flex items-center gap-2">
                    <!-- Create mode actions -->
                    <template v-if="mode === 'create'">
                        <button class="rounded px-2 py-1 text-sm hover:bg-gray-100" @click="$emit('close')">
                            Cancel
                        </button>
                        <button
                            :disabled="saving || !formTitle"
                            class="rounded bg-gray-900 px-3 py-1.5 text-sm text-white hover:bg-gray-800 disabled:opacity-60"
                            @click="createTask"
                        >
                            <span v-if="saving">Saving…</span><span v-else>Save</span>
                        </button>
                    </template>

                    <!-- Editing actions -->
                    <template v-else-if="isEditing">
                        <button class="rounded px-2 py-1 text-sm hover:bg-gray-100" @click="isEditing = false">
                            Cancel
                        </button>
                        <button
                            :disabled="!editTitle"
                            class="rounded bg-emerald-600 px-3 py-1.5 text-sm text-white hover:bg-emerald-500 disabled:opacity-60"
                            @click="saveEdit"
                        >
                            Save
                        </button>
                    </template>

                    <!-- View mode actions -->
                    <template v-else>
                        <button class="rounded px-2 py-1 text-sm hover:bg-gray-100" @click="startEdit">Edit</button>
                        <button
                            class="rounded bg-red-600 px-3 py-1.5 text-sm text-white hover:bg-red-500"
                            @click="removeTask"
                        >
                            Delete
                        </button>
                    </template>

                    <!-- Close (always) -->
                    <button class="rounded px-2 py-1 text-sm hover:bg-gray-100" @click="$emit('close')">✕</button>
                </div>
            </div>

            <!-- Body -->

            <!-- CREATE -->
            <div v-if="mode === 'create'" class="space-y-3">
                <label class="block text-sm font-medium">Title</label>
                <input
                    v-model.trim="formTitle"
                    class="w-full rounded-md border border-gray-300 px-3 py-2 focus:ring-2 focus:ring-emerald-400"
                    placeholder="Short summary"
                    autofocus
                />

                <label class="block text-sm font-medium">Description</label>
                <RichEditor :key="editorKey" v-model="formDesc" />
            </div>

            <!-- NOT CREATE: either EDIT or VIEW -->
            <div v-else>
                <!-- EDIT -->
                <div v-if="isEditing" class="space-y-3">
                    <label class="block text-sm font-medium">Title</label>
                    <input
                        v-model.trim="editTitle"
                        class="w-full rounded-md border border-gray-300 px-3 py-2 focus:ring-2 focus:ring-emerald-400"
                        placeholder="Task title"
                        autofocus
                    />

                    <label class="block text-sm font-medium">Description</label>
                    <RichEditor v-model="editDesc" />
                </div>

                <!-- VIEW -->
                <div v-else class="space-y-5">
                    <div>
                        <div class="flex items-start justify-between">
                            <div>
                                <div class="text-xl font-semibold">{{ task?.title }}</div>
                                <div class="mt-2 prose max-w-none">
                                    <SafeHtml :html="task?.description || ''" />
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Comments -->
                    <div class="border-t pt-4">
                        <div class="mb-2 text-sm font-medium text-gray-700">Comments</div>

                        <!-- Collapsed composer (Trello-style) -->
                        <button
                            v-if="!composerOpen"
                            class="w-full rounded-xl border px-4 py-3 text-left text-gray-500 hover:bg-gray-50"
                            @click="openComposer"
                        >
                            Write a comment…
                        </button>

                        <!-- Expanded rich composer -->
                        <div v-else class="space-y-2">
                            <RichEditor v-model="commentHtml" />
                            <div class="flex items-center gap-2">
                                <button
                                    :disabled="savingComment || !hasCommentContent"
                                    class="rounded bg-gray-900 px-3 py-1.5 text-sm text-white hover:bg-gray-800 disabled:opacity-60"
                                    @click="saveComment"
                                >
                                    {{ savingComment ? "Saving…" : "Save" }}
                                </button>
                                <button class="rounded px-2 py-1 text-sm hover:bg-gray-100" @click="cancelComment">
                                    Cancel
                                </button>
                            </div>
                        </div>

                        <!-- Comments list -->
                        <div v-if="loadingComments" class="mt-3 text-sm text-gray-500">Loading…</div>
                        <div v-else class="mt-3 max-h-60 overflow-y-auto pr-1">
                            <ul class="space-y-2">
                                <li v-for="c in comments" :key="c.id" class="rounded border bg-white p-2 text-sm">
                                    <div class="text-gray-800">
                                        <SafeHtml :html="c.body || ''" />
                                    </div>
                                    <div class="mt-1 text-xs text-gray-500">
                                        {{ new Date(c.created_at).toLocaleString() }}
                                    </div>
                                </li>
                                <li v-if="!comments.length" class="text-sm text-gray-500">No comments yet.</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <!-- /NOT CREATE -->
        </div>
    </div>
</template>

<script setup>
import { ref, watch, computed, nextTick } from "vue";
import { api } from "../lib/api";
import RichEditor from "./RichEditor.vue";
import SafeHtml from "./SafeHtml.vue";

const props = defineProps({
    open: { type: Boolean, default: false },
    mode: { type: String, default: "create" }, // 'create' | 'view'
    listId: { type: String, default: "" }, // used in create mode
    task: { type: Object, default: null }, // used in view mode
});

const emit = defineEmits(["close", "created", "commented", "updated", "deleted"]);

// --- create mode state
const formTitle = ref("");
const formDesc = ref("");
const saving = ref(false);
const editorKey = ref("editor-boot");

// --- view mode / comments state
const comments = ref([]);
const loadingComments = ref(false);

// New Trello-style composer state
const composerOpen = ref(false);
const commentHtml = ref("");
const savingComment = ref(false);

const hasCommentContent = computed(() => {
    const html = (commentHtml.value || "").replace(/<br\s*\/?>/gi, "\n");
    const text = html
        .replace(/<[^>]+>/g, "")
        .replace(/&nbsp;/g, " ")
        .trim();
    return text.length > 0;
});

// --- edit mode state
const isEditing = ref(false);
const editTitle = ref("");
const editDesc = ref("");

function initForm() {
    if (props.mode === "create") {
        formTitle.value = "";
        formDesc.value = "";
    } else if (props.task) {
        formTitle.value = props.task.title || "";
        formDesc.value = props.task.description || "";
    }
    // force remount RichEditor so it doesn't keep stale content
    editorKey.value = `${props.task?.id || "new"}-${Date.now()}`;
}

watch(
    () => props.open,
    (o) => {
        if (o) initForm();
    }
);
watch(
    () => props.mode,
    () => initForm(),
    { immediate: true }
);
watch(
    () => props.task?.id,
    () => initForm()
);

// load comments when opening in view mode
watch(
    () => [props.open, props.mode, props.task?.id],
    async ([open, mode]) => {
        if (!open || mode !== "view" || !props.task?.id) return;
        loadingComments.value = true;
        try {
            comments.value = await api.get(`/api/comments?task_id=${encodeURIComponent(props.task.id)}`);
        } catch (e) {
            console.error(e);
        } finally {
            loadingComments.value = false;
        }
    }
);

// also reset edit/composer state on open/close
watch(
    () => props.open,
    (o) => {
        if (o) {
            isEditing.value = false;
            composerOpen.value = false;
            commentHtml.value = "";
        } else {
            isEditing.value = false;
            composerOpen.value = false;
            commentHtml.value = "";
        }
    }
);

// ----- create task
async function createTask() {
    if (!formTitle.value.trim() || !props.listId) return;
    saving.value = true;
    try {
        const payload = {
            list_id: props.listId,
            title: formTitle.value.trim(),
            description: formDesc.value || "",
        };
        const res = await api.post("/api/tasks", payload);
        emit("created", { ...res, description: formDesc.value || "" });
        emit("close");
    } catch (e) {
        alert(e?.message || "Create failed");
    } finally {
        saving.value = false;
    }
}

// ----- comments (Trello-style)
function openComposer() {
    composerOpen.value = true;
    nextTick(() => {
        // editor will autofocus caret itself; no-op here
    });
}
function cancelComment() {
    composerOpen.value = false;
    commentHtml.value = "";
}
async function saveComment() {
    const body = commentHtml.value || "";
    if (!props.task?.id || !hasCommentContent.value) return;
    savingComment.value = true;
    try {
        const c = await api.post("/api/comments", { task_id: props.task.id, body });
        comments.value.unshift(c);
        commentHtml.value = "";
        composerOpen.value = false;
        emit("commented", c); // let Board bump comment_count if it wants
    } catch (e) {
        alert(e?.message || "Failed to comment");
    } finally {
        savingComment.value = false;
    }
}

// ----- edit task
function startEdit() {
    if (!props.task) return;
    isEditing.value = true;
    editTitle.value = props.task.title || "";
    editDesc.value = props.task.description || "";
}
async function saveEdit() {
    if (!props.task?.id) return;
    try {
        const payload = { title: editTitle.value, description: editDesc.value };
        const res = await api.patch(`/api/tasks?id=${encodeURIComponent(props.task.id)}`, payload);
        emit("updated", res);
        isEditing.value = false;
        emit("close");
    } catch (e) {
        alert(e?.message || "Failed to update task");
    }
}
async function removeTask() {
    if (!props.task?.id) return;
    if (!confirm("Are you sure you want to delete this task?")) return;
    try {
        await api.del(`/api/tasks?id=${encodeURIComponent(props.task.id)}`);
        emit("deleted", props.task.id);
        emit("close");
    } catch (e) {
        alert(e?.message || "Failed to delete task");
    }
}
</script>

<style scoped>
/* Small UX helpers */
</style>


===== END FILE =====


===== BEGIN FILE: web\src\lib\api.js =====

// web/src/lib/api.js
function getCookie(name) {
    return (
        document.cookie
            .split("; ")
            .find((row) => row.startsWith(name + "="))
            ?.split("=")[1] ?? ""
    );
}

async function request(path, { method = "GET", headers = {}, body } = {}) {
    const isMutation = !["GET", "HEAD"].includes(method.toUpperCase());
    const finalHeaders = new Headers(headers);
    finalHeaders.set("Accept", "application/json");

    // JSON body for mutations unless caller sets something else
    let payload = body;
    if (isMutation && body && !(body instanceof FormData)) {
        finalHeaders.set("Content-Type", "application/json");
        payload = JSON.stringify(body);
    }

    // CSRF for mutations if present
    if (isMutation) {
        const csrf = getCookie("csrf");
        if (csrf) finalHeaders.set("X-CSRF-Token", csrf);
    }

    const res = await fetch(path, {
        method,
        headers: finalHeaders,
        body: payload,
        credentials: "include", // send cookies (sid/csrf)
    });

    // Try to parse JSON if server says it's JSON
    const ctype = res.headers.get("content-type") || "";
    const looksJson = ctype.toLowerCase().startsWith("application/json");
    const data = looksJson ? await res.json().catch(() => null) : await res.text();

    if (!res.ok) {
        const msg = (data && data.error) || (typeof data === "string" ? data : "") || `HTTP ${res.status}`;
        const err = new Error(msg);
        err.status = res.status;
        err.data = data;
        throw err;
    }
    return data;
}

export const api = {
    get: (path, opts = {}) => request(path, { ...opts, method: "GET" }),
    post: (path, body, opts = {}) => request(path, { ...opts, method: "POST", body }),
    put: (path, body, opts = {}) => request(path, { ...opts, method: "PUT", body }),
    patch: (path, body, opts = {}) => request(path, { ...opts, method: "PATCH", body }),
    del: (path, opts = {}) => request(path, { ...opts, method: "DELETE" }),
};


===== END FILE =====


===== BEGIN FILE: web\src\main.js =====

import { createApp } from "vue";
import { createPinia } from "pinia";
import router from "./router";
import "./style.css";
import App from "./App.vue";
import { api } from "./lib/api";
import { useAuth } from "./stores/auth";

if (import.meta.env.DEV) {
    // dev convenience
    // eslint-disable-next-line no-undef
    window.api = api;
}

const app = createApp(App);
const pinia = createPinia();
app.use(pinia);
app.use(router);

// 🔐 Try to restore user session on first load
useAuth(pinia)
    .fetchMe()
    .catch(() => {
        /* not logged in is fine */
    });

app.mount("#app");


===== END FILE =====


===== BEGIN FILE: web\src\router.js =====

// web/src/router.js
import { createRouter, createWebHistory } from "vue-router";
import Home from "./views/Home.vue";

export default createRouter({
    history: createWebHistory(),
    routes: [
        { path: "/", name: "home", component: Home },
        { path: "/login", name: "login", component: () => import("./views/Login.vue") },
        { path: "/board", name: "board", component: () => import("./views/Board.vue") },
        { path: "/register", name: "register", component: () => import("./views/Register.vue") },
    ],
});


===== END FILE =====


===== BEGIN FILE: web\src\stores\auth.js =====

import { defineStore } from "pinia";
import { api } from "../lib/api";

export const useAuth = defineStore("auth", {
    state: () => ({ user: null, loading: false, error: "" }),
    getters: { isAuthed: (s) => !!s.user },
    actions: {
        async fetchMe() {
            this.loading = true;
            this.error = "";
            try {
                const me = await api.get("/api/me");
                this.user = me;
                return me;
            } catch (e) {
                if (e?.status === 401) this.user = null;
                else this.error = e?.message || "Failed to load user";
                throw e;
            } finally {
                this.loading = false;
            }
        },
        async login(email, password) {
            this.loading = true;
            this.error = "";
            try {
                await api.post("/api/login", { email, password });
                await this.fetchMe();
            } catch (e) {
                this.error = e?.message || "Login failed";
                throw e;
            } finally {
                this.loading = false;
            }
        },
        clientLogout() {
            this.user = null;
            this.error = "";
        },
    },
});


===== END FILE =====


===== BEGIN FILE: web\src\style.css =====

@import "tailwindcss";


===== END FILE =====


===== BEGIN FILE: web\src\views\Board.vue =====

<!-- web/src/views/Board.vue -->
<template>
    <div class="mx-auto max-w-7xl p-6">
        <div class="mb-4 flex items-center gap-3">
            <h1 class="text-2xl font-semibold">Board</h1>
            <button
                @click="loadBoard"
                :disabled="loading"
                class="rounded-md bg-gray-900 px-3 py-1.5 text-sm font-medium text-white hover:bg-gray-800 disabled:opacity-60"
            >
                {{ loading ? "Loading…" : "Refresh" }}
            </button>
            <div v-if="error" class="rounded-md border border-red-200 bg-red-50 px-3 py-2 text-sm text-red-700">
                <span v-if="error.toLowerCase().includes('unauthorized')">
                    You need to log in to view boards.
                    <RouterLink to="/login" class="underline">Go to Login</RouterLink>
                </span>
                <span v-else>{{ error }}</span>
            </div>
        </div>

        <div v-if="board" class="space-y-2">
            <h2 class="text-lg font-medium text-gray-700">{{ board.name }}</h2>

            <!-- Lists (draggable as a row) -->
            <Draggable
                v-model="board.lists"
                item-key="id"
                group="lists"
                :animation="180"
                ghost-class="drag-list-ghost"
                chosen-class="drag-list-chosen"
                drag-class="drag-list-dragging"
                tag="div"
                class="flex gap-4 overflow-x-auto pb-2 items-start"
                @change="onListChange"
            >
                <template #item="{ element: l, index }">
                    <div :key="l.id" class="w-72 shrink-0 rounded-lg border border-gray-200 bg-white">
                        <div class="border-b border-gray-200 px-4 py-2 cursor-grab">
                            <div class="flex items-center justify-between">
                                <span class="font-medium">{{ l.name }}</span>
                                <!-- show live index to reflect client-side reorder instantly -->
                                <span class="text-xs text-gray-500">pos {{ index }}</span>
                            </div>
                        </div>

                        <!-- Tasks in this list (draggable, cross-list moves enabled) -->
                        <draggable
                            v-model="l.tasks"
                            group="tasks"
                            item-key="id"
                            class="space-y-2 p-3 list-none"
                            :data-list-id="l.id"
                            @add="onTaskAdd"
                            @change="(e) => onTaskOrderChange(e, l)"
                            ghost-class="drag-task-ghost"
                            chosen-class="drag-task-chosen"
                            drag-class="drag-task-dragging"
                        >
                            <template #item="{ element: t }">
                                <li
                                    class="rounded-md border border-emerald-200 bg-emerald-50 p-3 cursor-pointer hover:bg-emerald-100"
                                    @click="openTask(t)"
                                >
                                    <div class="flex items-center justify-between">
                                        <span class="font-medium">{{ t.title }}</span>
                                        <span class="text-xs uppercase tracking-wide text-gray-600">{{
                                            t.status
                                        }}</span>
                                    </div>
                                    <div class="mt-2 flex items-center gap-3 text-sm text-gray-600">
                                        <span class="flex items-center gap-1">
                                            <ChatBubbleLeftIcon class="h-4 w-4 text-gray-500" /> {{ t.comment_count }}
                                        </span>
                                        <span class="flex items-center gap-1">
                                            <UserIcon class="h-4 w-4 text-gray-500" /> x{{ t.assignees?.length || 0 }}
                                        </span>
                                        <span class="ml-auto text-xs text-gray-400">pos {{ t.position }}</span>
                                    </div>
                                </li>
                            </template>
                            <template #footer>
                                <li v-if="!l.tasks?.length" class="px-3 py-2 text-sm text-gray-500">No tasks</li>
                            </template>
                        </draggable>

                        <button
                            class="m-3 mt-1 w-[calc(100%-1.5rem)] rounded-md border border-dashed border-gray-300 py-2 text-sm text-gray-600 hover:border-gray-400 hover:bg-white"
                            @click="openCreate(l.id)"
                        >
                            + Add task
                        </button>
                    </div>
                </template>
            </Draggable>
            <!-- /Lists -->
        </div>

        <p v-else class="text-gray-600">No board loaded yet.</p>
    </div>

    <TaskModal
        :open="showModal"
        :mode="modalMode"
        :listId="targetListId"
        :task="activeTask"
        @close="showModal = false"
        @created="onCreated"
        @commented="onCommented"
        @updated="onUpdated"
        @deleted="onDeleted"
    />
</template>

<script setup>
import { ref, watchEffect } from "vue";
import { useRoute } from "vue-router";
import { api } from "../lib/api";
import { ChatBubbleLeftIcon, UserIcon } from "@heroicons/vue/24/outline";
import TaskModal from "../components/TaskModal.vue";
import Draggable from "vuedraggable"; // Lists
import draggable from "vuedraggable"; // Tasks (same component; using both tags is fine)

const route = useRoute();
const loading = ref(false);
const error = ref("");

// Keep board reactive; null is fine initially
const board = ref(null);

// --- load board (first by default, or ?id=...)
async function loadBoard() {
    loading.value = true;
    error.value = "";
    try {
        const id = route.query.id;
        const url = id ? `/api/boards?id=${encodeURIComponent(id)}` : "/api/boards";
        board.value = await api.get(url);
    } catch (e) {
        error.value = e?.message || "Failed to load board";
    } finally {
        loading.value = false;
    }
}

// auto-load on mount and when ?id changes
watchEffect(() => {
    route.query.id; // track dep
    loadBoard();
});

// ----- Modal orchestration -----
const showModal = ref(false);
const modalMode = ref("create"); // "create" | "view"
const targetListId = ref(""); // used for create
const activeTask = ref(null); // keep a REFERENCE to the task in board.lists

function openCreate(listId) {
    modalMode.value = "create";
    targetListId.value = listId;
    activeTask.value = null;
    showModal.value = true;
}

function openTask(task) {
    // IMPORTANT: keep reference, do NOT clone
    console.log("[Board] openTask:", { id: task.id, title: task.title, hasDescription: !!task.description });
    modalMode.value = "view";
    activeTask.value = task;
    targetListId.value = "";
    showModal.value = true;
}

// ----- Events from TaskModal -----

function onCreated(res) {
    console.log("[Board] onCreated:", res);
    if (!board.value?.lists?.length) return;
    const list =
        board.value.lists.find((l) => l.id === res.list_id) ||
        board.value.lists.find((l) => l.id === targetListId.value);
    if (!list) return;
    if (!Array.isArray(list.tasks)) list.tasks = [];
    list.tasks.push({
        id: res.id,
        list_id: res.list_id,
        title: res.title,
        description: res.description || "",
        status: res.status,
        position: res.position,
        assignees: res.assignees ?? [],
        comment_count: 0,
    });
}

function onCommented(c) {
    const taskId = activeTask.value?.id ?? c.task_id;
    if (!taskId || !board.value?.lists?.length) return;
    for (const list of board.value.lists) {
        const card = list.tasks?.find((t) => t.id === taskId);
        if (card) {
            card.comment_count = (card.comment_count || 0) + 1;
            break;
        }
    }
}

function onUpdated(updated) {
    console.log("[Board] onUpdated:", updated);
    if (!updated?.id || !board.value?.lists?.length) return;
    for (const list of board.value.lists) {
        const idx = list.tasks?.findIndex((t) => t.id === updated.id) ?? -1;
        if (idx !== -1) {
            const prev = list.tasks[idx];
            list.tasks.splice(idx, 1, {
                ...prev,
                title: updated.title ?? prev.title,
                description: updated.description ?? prev.description,
                status: updated.status ?? prev.status,
                position: typeof updated.position === "number" ? updated.position : prev.position,
            });
            break;
        }
    }
}

function onDeleted(taskId) {
    console.log("[Board] onDeleted:", taskId);
    if (!taskId || !board.value?.lists?.length) return;
    for (const list of board.value.lists) {
        const idx = list.tasks?.findIndex((t) => t.id === taskId) ?? -1;
        if (idx !== -1) {
            list.tasks.splice(idx, 1);
            break;
        }
    }
}

// ===== DND: Tasks =====
const lastFromListId = ref(""); // set by @add, used by @change(added)

function onTaskAdd(evt) {
    // evt is a CustomEvent from Sortable with DOM refs
    lastFromListId.value = evt?.from?.dataset?.listId || "";
    console.log("[DND] add: fromListId =", lastFromListId.value);
}

async function onTaskOrderChange(evt, destList) {
    const { moved, added } = evt;

    // Same-list reorder
    if (moved) {
        const payload = {
            task_id: moved.element?.id,
            to_list_id: destList.id,
            to_index: moved.newIndex ?? 0,
        };
        try {
            await api.post("/api/tasks/reorder", payload);
            console.log("[DND] persisted same-list reorder", payload);
        } catch (e) {
            console.error("persist failed", e);
            // optional: await loadBoard();
        }
    }

    // Cross-list move (destination side)
    if (added) {
        const payload = {
            task_id: added.element?.id,
            to_list_id: destList.id,
            to_index: added.newIndex ?? 0,
        };
        try {
            await api.post("/api/tasks/reorder", payload);
            console.log("[DND] persisted cross-list move", payload);
        } catch (e) {
            console.error("persist failed", e);
            // optional: await loadBoard();
        }
    }
}

// ===== DND: Lists =====
async function onListChange() {
    if (!board.value?.lists?.length) return;
    const order = board.value.lists.map((l) => l.id);
    console.log("[DND][lists] new order:", order);
    try {
        await api.post("/api/lists/reorder", { board_id: board.value.id, list_ids: order });
        console.log("[DND][lists] persisted");
    } catch (e) {
        console.error("List reorder failed:", e?.message || e);
        // optional: await loadBoard();
    }
}
</script>

<style scoped>
/* Task drag visuals */
.drag-task-ghost {
    background-color: #e5e7eb; /* gray-200 */
    border: 2px dashed #9ca3af; /* gray-400 */
    min-height: 3.5rem;
    border-radius: 0.375rem;
    opacity: 0.6;
}
.drag-task-chosen {
    opacity: 0.5;
}
.drag-task-dragging {
    cursor: grabbing;
}

/* List drag visuals */
.drag-list-ghost {
    opacity: 0.5;
    transform: scale(0.98);
}
.drag-list-chosen {
    opacity: 0.8;
}
.drag-list-dragging {
    cursor: grabbing;
}
</style>


===== END FILE =====


===== BEGIN FILE: web\src\views\Home.vue =====

<template>
    <div class="space-y-4">
        <h1 class="text-2xl font-semibold">Welcome</h1>

        <div v-if="auth.isAuthed" class="flex items-center gap-3">
            <span class="text-gray-700"
                >Signed in as <strong>{{ auth.user?.name }}</strong></span
            >
            <button @click="onLogout" class="rounded-md bg-gray-900 px-3 py-1.5 text-white hover:bg-gray-800">
                Logout
            </button>
        </div>

        <div v-else>
            <RouterLink to="/login" class="underline">Login</RouterLink>
            <span class="mx-1">·</span>
            <RouterLink to="/register" class="underline">Register</RouterLink>
        </div>
    </div>
</template>

<script setup>
import { useRouter } from "vue-router";
import { useAuth } from "../stores/auth";
import { api } from "../lib/api";

const router = useRouter();
const auth = useAuth();

async function onLogout() {
    try {
        await api.post("/api/logout", {}); // clears cookies server-side
    } catch (_) {}
    // reset client state
    auth.$reset?.(); // if defined; otherwise:
    auth.user = null;
    auth.isAuthed = false;
    router.push("/login");
}
</script>


===== END FILE =====


===== BEGIN FILE: web\src\views\Login.vue =====

<template>
    <div class="mx-auto max-w-sm py-10">
        <h1 class="mb-6 text-2xl font-semibold">Login</h1>

        <form @submit.prevent="onSubmit" class="space-y-4">
            <div>
                <label class="mb-1 block text-sm font-medium">Email</label>
                <input
                    v-model.trim="email"
                    type="email"
                    required
                    class="w-full rounded-md border border-gray-300 bg-white px-3 py-2 outline-none focus:ring-2 focus:ring-emerald-400"
                    placeholder="you@example.com"
                />
            </div>

            <div>
                <label class="mb-1 block text-sm font-medium">Password</label>
                <input
                    v-model="password"
                    type="password"
                    required
                    class="w-full rounded-md border border-gray-300 bg-white px-3 py-2 outline-none focus:ring-2 focus:ring-emerald-400"
                    placeholder="••••••••"
                />
            </div>

            <button
                type="submit"
                :disabled="auth.loading"
                class="w-full rounded-md bg-gray-900 px-4 py-2 font-medium text-white hover:bg-gray-800 disabled:opacity-60"
            >
                <span v-if="auth.loading">Signing in…</span>
                <span v-else>Sign in</span>
            </button>

            <p v-if="auth.error" class="text-sm text-red-600">{{ auth.error }}</p>
        </form>

        <p class="mt-6 text-sm text-gray-600">
            Don’t have an account?
            <RouterLink to="/register" class="underline">Register</RouterLink>
        </p>
    </div>
</template>

<script setup>
import { ref } from "vue";
import { useRouter } from "vue-router";
import { useAuth } from "../stores/auth";

const email = ref("");
const password = ref("");
const auth = useAuth();
const router = useRouter();

async function onSubmit() {
    try {
        await auth.login(email.value, password.value);
        router.push("/");
    } catch {
        /* error shown by store */
    }
}
</script>

<style scoped></style>


===== END FILE =====


===== BEGIN FILE: web\src\views\Register.vue =====

<template>
    <div class="mx-auto max-w-sm py-10">
        <h1 class="mb-6 text-2xl font-semibold">Register</h1>

        <form @submit.prevent="onSubmit" class="space-y-4">
            <div>
                <label class="mb-1 block text-sm font-medium">Name</label>
                <input
                    v-model.trim="name"
                    required
                    class="w-full rounded-md border border-gray-300 bg-white px-3 py-2 outline-none focus:ring-2 focus:ring-emerald-400"
                />
            </div>

            <div>
                <label class="mb-1 block text-sm font-medium">Email</label>
                <input
                    v-model.trim="email"
                    type="email"
                    required
                    class="w-full rounded-md border border-gray-300 bg-white px-3 py-2 outline-none focus:ring-2 focus:ring-emerald-400"
                />
            </div>

            <div>
                <label class="mb-1 block text-sm font-medium">Password</label>
                <input
                    v-model="password"
                    type="password"
                    required
                    class="w-full rounded-md border border-gray-300 bg-white px-3 py-2 outline-none focus:ring-2 focus:ring-emerald-400"
                />
            </div>

            <button
                type="submit"
                :disabled="loading"
                class="w-full rounded-md bg-gray-900 px-4 py-2 font-medium text-white hover:bg-gray-800 disabled:opacity-60"
            >
                <span v-if="loading">Creating account…</span>
                <span v-else>Register</span>
            </button>

            <p v-if="error" class="text-sm text-red-600">{{ error }}</p>
        </form>

        <p class="mt-6 text-sm text-gray-600">
            Already have an account?
            <RouterLink to="/login" class="underline">Login</RouterLink>
        </p>
    </div>
</template>

<script setup>
import { ref } from "vue";
import { useRouter } from "vue-router";
import { api } from "../lib/api";

const name = ref("");
const email = ref("");
const password = ref("");
const loading = ref(false);
const error = ref("");
const router = useRouter();

async function onSubmit() {
    loading.value = true;
    error.value = "";
    try {
        await api.post("/api/register", { name: name.value, email: email.value, password: password.value });
        await api.post("/api/login", { email: email.value, password: password.value });
        router.push("/board");
    } catch (e) {
        error.value = e?.message || "Registration failed";
    } finally {
        loading.value = false;
    }
}
</script>


===== END FILE =====


===== BEGIN FILE: web\vite.config.js =====

// vite.config.js
import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";
import tailwindcss from "@tailwindcss/vite";

export default defineConfig({
    plugins: [vue(), tailwindcss()],
    server: {
        host: true,
        port: 5173,
        strictPort: true,
        hmr: {
            host: "localhost",
            clientPort: 5173,
            protocol: "ws",
        },
        watch: {
            usePolling: true,
            interval: 300,
        },
        proxy: {
            "/api": { target: "http://api:8080", changeOrigin: true },
            "/uploads": { target: "http://api:8080", changeOrigin: true }, // ← required
        },
    },
});


===== END FILE =====

