### PROJECT SNAPSHOT
Generated: 2025-09-16 12:29:53 +03:00
Root: C:\Users\denis_particleformen\Desktop\docker-projects\task-manager

--- PROJECT STRUCTURE (filtered) ---

[DIR] .
  - .env
  - .env.example
  - .gitignore
  - cookies.txt
  - docker-compose.yml
  - README.md
[DIR] db\migrations
  - 0001_users.down.sql
  - 0001_users.up.sql
  - 0002_boards_and_lists.down.sql
  - 0002_boards_and_lists.up.sql
  - 0003_tasks.down.sql
  - 0003_tasks.up.sql
  - 0004_task_creator_and_assignees.down.sql
  - 0004_task_creator_and_assignees.up.sql
  - 0005_comments.down.sql
  - 0005_comments.up.sql
  - 0006_workspaces.down.sql
  - 0006_workspaces.up.sql
[DIR] db\seed
  - seed.sql
[DIR] server
  - .air.toml
  - Dockerfile
  - go.mod
[DIR] server\cmd\api
  - handlers_auth.go
  - handlers_board.go
  - handlers_comments.go
  - main.go
  - routes.go
[DIR] web
  - .gitignore
  - Dockerfile
  - index.html
  - package.json
  - README.md
  - vite.config.js
[DIR] web\public
  - vite.svg
[DIR] web\src
  - App.vue
  - main.js
  - router.js
  - style.css
[DIR] web\src\assets
  - vue.svg
[DIR] web\src\components
  - HelloWorld.vue
[DIR] web\src\lib
  - api.js
[DIR] web\src\stores
  - auth.js
[DIR] web\src\views
  - Board.vue
  - Home.vue
  - Login.vue

--- FILE CONTENTS (filtered) ---


===== BEGIN FILE: .env =====

POSTGRES_USER=app
POSTGRES_PASSWORD=app
POSTGRES_DB=taskmgr
PGADMIN_DEFAULT_EMAIL=admin@example.com
PGADMIN_DEFAULT_PASSWORD=admin123
DB_DSN=postgres://app:app@db:5432/taskmgr?sslmode=disable

===== END FILE =====


===== BEGIN FILE: .env.example =====

POSTGRES_USER=app
POSTGRES_PASSWORD=app
POSTGRES_DB=taskmgr
PGADMIN_DEFAULT_EMAIL=admin@example.com
PGADMIN_DEFAULT_PASSWORD=admin123
DB_DSN=postgres://app:app@db:5432/taskmgr?sslmode=disable

===== END FILE =====


===== BEGIN FILE: .gitignore =====

# Node
node_modules/
web/node_modules/

# pnpm store (root + nested)
.pnpm-store/
web/.pnpm-store/
**/.pnpm-store/

# Build output
dist/

# Environment files
.env
.env.local
.env.*.local

# Editor/IDE settings
.vscode/
.idea/

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# OS junk
.DS_Store
Thumbs.db



# pnpm store (root + nested)
.pnpm-store/
web/.pnpm-store/
**/.pnpm-store/

# VS Code anywhere
**/.vscode/

===== END FILE =====


===== BEGIN FILE: cookies.txt =====

# Netscape HTTP Cookie File
# https://curl.se/docs/http-cookies.html
# This file was generated by libcurl! Edit at your own risk.

localhost	FALSE	/	FALSE	0	csrf	uHsWILA887UvLEJ3beSO9praf29z_TII
#HttpOnly_localhost	FALSE	/	FALSE	0	sid	OwZiYLS1I-gVD7-x3dN3NZBCkNEUS0O4


===== END FILE =====


===== BEGIN FILE: db\migrations\0001_users.down.sql =====

DROP TABLE IF EXISTS users;


===== END FILE =====


===== BEGIN FILE: db\migrations\0001_users.up.sql =====

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE IF NOT EXISTS users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  email TEXT NOT NULL UNIQUE,
  password_hash TEXT NOT NULL,
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);


===== END FILE =====


===== BEGIN FILE: db\migrations\0002_boards_and_lists.down.sql =====

DROP TABLE IF EXISTS lists;
DROP TABLE IF EXISTS boards;

===== END FILE =====


===== BEGIN FILE: db\migrations\0002_boards_and_lists.up.sql =====

-- Boards hold lists; simple for now (owner_id optional for later).
CREATE TABLE IF NOT EXISTS boards (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  owner_id UUID NULL REFERENCES users(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Lists (columns) belong to a board; position supports ordering left→right.
CREATE TABLE IF NOT EXISTS lists (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  board_id UUID NOT NULL REFERENCES boards(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  position INT NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Helpful indexes
CREATE INDEX IF NOT EXISTS idx_lists_board ON lists(board_id);
CREATE INDEX IF NOT EXISTS idx_lists_board_position ON lists(board_id, position);


===== END FILE =====


===== BEGIN FILE: db\migrations\0003_tasks.down.sql =====

DROP TABLE IF EXISTS tasks;

===== END FILE =====


===== BEGIN FILE: db\migrations\0003_tasks.up.sql =====

CREATE TABLE IF NOT EXISTS tasks (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  list_id UUID NOT NULL REFERENCES lists(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT NOT NULL DEFAULT '',
  position INT NOT NULL DEFAULT 0,                    -- order within a list (left→right top→bottom)
  status TEXT NOT NULL DEFAULT 'todo',                -- we'll normalize later if needed
  assignee_id UUID NULL REFERENCES users(id) ON DELETE SET NULL,
  due_date DATE NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- quick lookups & ordered pulls
CREATE INDEX IF NOT EXISTS idx_tasks_list ON tasks(list_id);
CREATE INDEX IF NOT EXISTS idx_tasks_list_position ON tasks(list_id, position);
CREATE INDEX IF NOT EXISTS idx_tasks_assignee ON tasks(assignee_id);


===== END FILE =====


===== BEGIN FILE: db\migrations\0004_task_creator_and_assignees.down.sql =====

DROP TABLE IF EXISTS task_assignees;
ALTER TABLE tasks DROP COLUMN IF EXISTS created_by;

===== END FILE =====


===== BEGIN FILE: db\migrations\0004_task_creator_and_assignees.up.sql =====

-- Add creator to tasks
ALTER TABLE tasks
  ADD COLUMN created_by UUID NULL REFERENCES users(id) ON DELETE SET NULL;

-- Many-to-many assignees
CREATE TABLE IF NOT EXISTS task_assignees (
  task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  assigned_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  PRIMARY KEY (task_id, user_id)
);

-- Helpful indexes (optional but nice)
CREATE INDEX IF NOT EXISTS idx_task_assignees_user ON task_assignees(user_id);


===== END FILE =====


===== BEGIN FILE: db\migrations\0005_comments.down.sql =====

DROP TABLE IF EXISTS comments;

===== END FILE =====


===== BEGIN FILE: db\migrations\0005_comments.up.sql =====

CREATE TABLE IF NOT EXISTS comments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  task_id   UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
  author_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  body TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_comments_task ON comments(task_id);


===== END FILE =====


===== BEGIN FILE: db\migrations\0006_workspaces.down.sql =====

ALTER TABLE boards DROP COLUMN IF EXISTS workspace_id;
DROP TABLE IF EXISTS workspace_members;
DROP TABLE IF EXISTS workspaces;


===== END FILE =====


===== BEGIN FILE: db\migrations\0006_workspaces.up.sql =====

CREATE TABLE IF NOT EXISTS workspaces (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  slug TEXT UNIQUE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS workspace_members (
  workspace_id UUID NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  role TEXT NOT NULL DEFAULT 'member',
  PRIMARY KEY (workspace_id, user_id)
);

ALTER TABLE boards
  ADD COLUMN workspace_id UUID NULL REFERENCES workspaces(id) ON DELETE CASCADE;

CREATE INDEX IF NOT EXISTS idx_boards_workspace ON boards(workspace_id);


===== END FILE =====


===== BEGIN FILE: db\seed\seed.sql =====

-- DEV-ONLY SEED. Run after `migrate up` on an empty DB.

-- 1) One demo user
INSERT INTO users (email, password_hash, name)
VALUES ('demo@example.com', 'x', 'Demo User')
ON CONFLICT (email) DO NOTHING;

-- 2) One board
WITH u AS (
  SELECT id FROM users WHERE email = 'demo@example.com'
),
b AS (
  INSERT INTO boards (name, owner_id)
  SELECT 'Demo Board', u.id FROM u
  RETURNING id
)
-- 3) Three lists
INSERT INTO lists (board_id, name, position)
SELECT id, 'To Do', 0 FROM b
UNION ALL SELECT id, 'In Progress', 1 FROM b
UNION ALL SELECT id, 'Done', 2 FROM b;

-- 4) A few tasks into "To Do"
WITH
  b AS (SELECT id FROM boards WHERE name = 'Demo Board'),
  l AS (
    SELECT id FROM lists WHERE board_id = (SELECT id FROM b) AND name = 'To Do'
  ),
  u AS (SELECT id FROM users WHERE email = 'demo@example.com')
INSERT INTO tasks (list_id, title, description, position, status, created_by, due_date)
SELECT (SELECT id FROM l), 'Wire API → DB', 'Ping DB + version()', 0, 'in_progress', (SELECT id FROM u), CURRENT_DATE + 3
UNION ALL
SELECT (SELECT id FROM l), 'Add migrations', 'users, boards, lists, tasks, comments', 1, 'todo', (SELECT id FROM u), CURRENT_DATE + 5
UNION ALL
SELECT (SELECT id FROM l), 'Vue proxy', 'Vite → Go via /api/*', 2, 'todo', (SELECT id FROM u), NULL;

-- 5) Assign demo user to first task
WITH t AS (
  SELECT id FROM tasks ORDER BY created_at ASC LIMIT 1
),
u AS (SELECT id FROM users WHERE email = 'demo@example.com')
INSERT INTO task_assignees (task_id, user_id)
SELECT t.id, u.id FROM t, u
ON CONFLICT DO NOTHING;

-- 6) One comment on first task
WITH t AS (
  SELECT id FROM tasks ORDER BY created_at ASC LIMIT 1
),
u AS (SELECT id FROM users WHERE email = 'demo@example.com')
INSERT INTO comments (task_id, author_id, body)
SELECT t.id, u.id, 'First!' FROM t, u;



-- Workspaces (demo)
WITH u AS (
  SELECT id FROM users WHERE email = 'demo@example.com'
),
w AS (
  INSERT INTO workspaces (name, slug)
  VALUES ('Demo Workspace', 'demo')
  ON CONFLICT (slug) DO UPDATE SET name = EXCLUDED.name
  RETURNING id
)
INSERT INTO workspace_members (workspace_id, user_id, role)
SELECT w.id, u.id, 'owner' FROM w, u
ON CONFLICT DO NOTHING;

-- Attach existing boards to demo workspace if not set
UPDATE boards
SET workspace_id = (SELECT id FROM workspaces WHERE slug = 'demo')
WHERE workspace_id IS NULL;

===== END FILE =====


===== BEGIN FILE: docker-compose.yml =====

services:
    db:
        image: postgres:16
        container_name: tm_db
        restart: unless-stopped
        environment:
            POSTGRES_USER: ${POSTGRES_USER}
            POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
            POSTGRES_DB: ${POSTGRES_DB}
        ports:
            - "5432:5432"
        volumes:
            - pgdata:/var/lib/postgresql/data

    pgadmin:
        image: dpage/pgadmin4
        container_name: tm_pgadmin
        restart: unless-stopped
        environment:
            PGADMIN_DEFAULT_EMAIL: ${PGADMIN_DEFAULT_EMAIL}
            PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_DEFAULT_PASSWORD}
        ports:
            - "5050:80"
        depends_on:
            - db
    api:
        build:
            context: ./server
            dockerfile: Dockerfile
        container_name: tm_api
        command: ["air", "-c", ".air.toml", "-build.poll", "true", "-build.poll_interval", "1000"]
        working_dir: /app
        volumes:
            - ./server:/app
        ports:
            - "8080:8080"
        depends_on:
            - db
        environment:
            - DB_DSN=${DB_DSN}

    web:
        build:
            context: ./web
            dockerfile: Dockerfile
        container_name: tm_web
        command:
            ["bash", "-lc", "corepack enable && corepack prepare pnpm@9 --activate && pnpm install && pnpm dev --host"]
        working_dir: /app
        volumes:
            - ./web:/app
            - /app/node_modules
            - pnpmstore:/app/.pnpm-store
        ports:
            - "5173:5173"
        depends_on:
            - api

    migrate:
        image: migrate/migrate:4
        volumes:
            - ./db/migrations:/migrations
        depends_on:
            - db
        entrypoint: ["migrate"]
        command: ["-path", "/migrations", "-database", "postgres://app:app@db:5432/taskmgr?sslmode=disable", "up"]

    seed:
        image: postgres:16
        depends_on:
            - db
        volumes:
            - ./db/seed:/seed
        environment:
            PGPASSWORD: ${POSTGRES_PASSWORD}
        entrypoint: ["psql"]
        command: ["-h", "db", "-U", "${POSTGRES_USER}", "-d", "${POSTGRES_DB}", "-f", "/seed/seed.sql"]

volumes:
    pgdata:
    pnpmstore:


===== END FILE =====


===== BEGIN FILE: README.md =====

# Task Manager

Mono-repo with Go API, Vue 3 web app, and Postgres (via Docker).

## Structure
- **server/** � Go backend (API, auth, tasks, comments)
- **web/** � Vue 3 frontend (Vite, Pinia, Router)
- **db/migrations/** � SQL migrations (golang-migrate)
- **docker/** � Dockerfiles / scripts
- **docker-compose.yml** � (later) dev stack runner

## Dev Targets (MVP)
- Auth: register/login/logout
- Tasks: CRUD, assign, status, due date
- Comments: per task
- Filters/search

## Next Steps
1) Skeleton now.
2) Prereqs: Docker Desktop, Go, Node LTS.
3) Docker Compose for dev (db/api/web).
4) Minimal health endpoints.
## DB Quick Access
- pgAdmin: http://localhost:5050  
  - Add Server ? Host: db, User: app, Password: app


===== END FILE =====


===== BEGIN FILE: server\.air.toml =====

root = "."
tmp_dir = "tmp"
poll = true
poll_interval = 1000
[build]
cmd = "go build -o ./tmp/api ./cmd/api"
bin = "./tmp/api"
include_ext = ["go"]
exclude_dir = ["tmp","vendor"]
delay = 1000


===== END FILE =====


===== BEGIN FILE: server\cmd\api\handlers_auth.go =====

package main

import (
	"crypto/rand"
	"database/sql"
	"encoding/base64"
	"encoding/json"
	"log"
	"net/http"
	"strings"
	"sync"
	"time"

	"golang.org/x/crypto/argon2"
)

// ---- password hashing ----

func hashPassword(pw string) (string, error) {
	salt := make([]byte, 16)
	if _, err := rand.Read(salt); err != nil {
		return "", err
	}
	const (
		timeCost    = 3
		memoryCost  = 64 * 1024
		parallelism = 1
		keyLen      = 32
	)
	dk := argon2.IDKey([]byte(pw), salt, timeCost, memoryCost, uint8(parallelism), keyLen)
	return "$argon2id$v=19$m=65536,t=3,p=1$" +
		base64.RawStdEncoding.EncodeToString(salt) + "$" +
		base64.RawStdEncoding.EncodeToString(dk), nil
}

func verifyPassword(pw, encoded string) bool {
	parts := strings.Split(encoded, "$")
	if len(parts) != 6 || parts[1] != "argon2id" {
		return false
	}
	salt, err1 := base64.RawStdEncoding.DecodeString(parts[4])
	want, err2 := base64.RawStdEncoding.DecodeString(parts[5])
	if err1 != nil || err2 != nil {
		return false
	}
	dk := argon2.IDKey([]byte(pw), salt, 3, 64*1024, 1, uint32(len(want)))
	if len(dk) != len(want) {
		return false
	}
	var v byte
	for i := range dk {
		v |= dk[i] ^ want[i]
	}
	return v == 0
}

// ---- session store (dev-only) ----

type Session struct {
	UserID  string
	CSRF    string
	Expires time.Time
}

var (
	sessions   = make(map[string]Session)
	sessionsMu sync.Mutex
)

func randToken(n int) string {
	b := make([]byte, n)
	_, _ = rand.Read(b)
	return base64.RawURLEncoding.EncodeToString(b) // URL-safe
}

// ---- /api/register ----

type registerReq struct {
	Email    string `json:"email"`
	Name     string `json:"name"`
	Password string `json:"password"`
}
type registerResp struct {
	ID    string `json:"id"`
	Email string `json:"email"`
	Name  string `json:"name"`
}

func registerHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	var req registerReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "bad json", http.StatusBadRequest)
		return
	}
	if req.Email == "" || req.Password == "" || req.Name == "" {
		http.Error(w, "missing fields", http.StatusBadRequest)
		return
	}
	h, err := hashPassword(req.Password)
	if err != nil {
		http.Error(w, "hashing failed", http.StatusInternalServerError)
		return
	}
	var id string
	err = db.QueryRow(
		`INSERT INTO users (email, password_hash, name) VALUES ($1,$2,$3) RETURNING id`,
		req.Email, h, req.Name,
	).Scan(&id)
	if err != nil {
		http.Error(w, "could not create user", http.StatusConflict)
		return
	}

	// 👇 best-effort provisioning (workspace + default board + lists)
	if err := provisionPersonalWorkspace(db, id, req.Name); err != nil {
		// Non-fatal for registration; just log it. User can still log in.
		log.Println("provisioning failed:", err)
	}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(registerResp{ID: id, Email: req.Email, Name: req.Name})
}

func provisionPersonalWorkspace(db *sql.DB, userID, userName string) error {
	tx, err := db.Begin()
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			_ = tx.Rollback()
		}
	}()

	// 1) workspace (slug NULL for now; keep it simple)
	var wsID string
	if err = tx.QueryRow(
		`INSERT INTO workspaces (name, slug) VALUES ($1, NULL) RETURNING id`,
		userName+"'s Workspace",
	).Scan(&wsID); err != nil {
		return err
	}

	// 2) membership (owner)
	if _, err = tx.Exec(
		`INSERT INTO workspace_members (workspace_id, user_id, role) VALUES ($1,$2,'owner')
         ON CONFLICT DO NOTHING`,
		wsID, userID,
	); err != nil {
		return err
	}

	// 3) default board
	var boardID string
	if err = tx.QueryRow(
		`INSERT INTO boards (name, owner_id, workspace_id) VALUES ($1,$2,$3) RETURNING id`,
		"My Board", userID, wsID,
	).Scan(&boardID); err != nil {
		return err
	}

	// 4) three starter lists
	if _, err = tx.Exec(
		`INSERT INTO lists (board_id, name, position)
         VALUES ($1,'To Do',0), ($1,'In Progress',1), ($1,'Done',2)`,
		boardID,
	); err != nil {
		return err
	}

	return tx.Commit()
}

// ---- /api/login ----

type loginReq struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}
type loginResp struct {
	UserID string `json:"user_id"`
}

func loginHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	var req loginReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "bad json", http.StatusBadRequest)
		return
	}
	if req.Email == "" || req.Password == "" {
		http.Error(w, "missing fields", http.StatusBadRequest)
		return
	}
	var userID, pwHash string
	err := db.QueryRow(`SELECT id, password_hash FROM users WHERE email=$1`, req.Email).Scan(&userID, &pwHash)
	if err == sql.ErrNoRows {
		http.Error(w, "invalid credentials", http.StatusUnauthorized)
		return
	} else if err != nil {
		http.Error(w, "login failed", http.StatusInternalServerError)
		return
	}
	if !verifyPassword(req.Password, pwHash) {
		http.Error(w, "invalid credentials", http.StatusUnauthorized)
		return
	}
	sid := randToken(24)
	csrf := randToken(24)
	sessionsMu.Lock()
	sessions[sid] = Session{UserID: userID, CSRF: csrf, Expires: time.Now().Add(24 * time.Hour)}
	sessionsMu.Unlock()

	http.SetCookie(w, &http.Cookie{
		Name:     "sid",
		Value:    sid,
		Path:     "/",
		HttpOnly: true,
		SameSite: http.SameSiteLaxMode,
	})
	http.SetCookie(w, &http.Cookie{
		Name:     "csrf",
		Value:    csrf,
		Path:     "/",
		HttpOnly: false,
		SameSite: http.SameSiteLaxMode,
	})
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(loginResp{UserID: userID})
}

// ---- /api/me ----

type meResp struct {
	ID    string `json:"id"`
	Email string `json:"email"`
	Name  string `json:"name"`
}

func getSessionFromRequest(r *http.Request) (Session, bool) {
	c, err := r.Cookie("sid")
	if err != nil || c.Value == "" {
		return Session{}, false
	}
	sessionsMu.Lock()
	s, ok := sessions[c.Value]
	sessionsMu.Unlock()
	if !ok || time.Now().After(s.Expires) {
		return Session{}, false
	}
	return s, true
}

func meHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	if r.Method != http.MethodGet {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	sess, ok := getSessionFromRequest(r)
	if !ok {
		http.Error(w, "unauthorized", http.StatusUnauthorized)
		return
	}
	var email, name string
	if err := db.QueryRow(`SELECT email, name FROM users WHERE id=$1`, sess.UserID).Scan(&email, &name); err != nil {
		http.Error(w, "user not found", http.StatusUnauthorized)
		return
	}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(meResp{ID: sess.UserID, Email: email, Name: name})
}

// ---- CSRF helper for POST/PUT/PATCH/DELETE ----

func requireAuthAndCSRF(w http.ResponseWriter, r *http.Request) (Session, bool) {
	s, ok := getSessionFromRequest(r)
	if !ok {
		http.Error(w, "unauthorized", http.StatusUnauthorized)
		return Session{}, false
	}
	token := r.Header.Get("X-CSRF-Token")
	if token == "" || token != s.CSRF {
		http.Error(w, "forbidden", http.StatusForbidden)
		return Session{}, false
	}
	return s, true
}


===== END FILE =====


===== BEGIN FILE: server\cmd\api\handlers_board.go =====

package main

import (
	"database/sql"
	"encoding/json"
	"net/http"
)

// ---- DTOs for board payload ----

type BoardDTO struct {
	ID    string    `json:"id"`
	Name  string    `json:"name"`
	Lists []ListDTO `json:"lists"`
}

type ListDTO struct {
	ID       string    `json:"id"`
	Name     string    `json:"name"`
	Position int       `json:"position"`
	Tasks    []TaskDTO `json:"tasks"`
}

type TaskDTO struct {
	ID           string   `json:"id"`
	Title        string   `json:"title"`
	Status       string   `json:"status"`
	Position     int      `json:"position"`
	Assignees    []string `json:"assignees"`
	CommentCount int      `json:"comment_count"`
}

// ---- Handler ----

func boardsHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	// 🔐 now requires auth (so we can scope by workspace membership)
	sess, ok := getSessionFromRequest(r)
	if !ok {
		http.Error(w, "unauthorized", http.StatusUnauthorized)
		return
	}

	qid := r.URL.Query().Get("id")
	inc := r.URL.Query().Get("include")

	var wantLists, wantTasks bool
	switch inc {
	case "", "lists,tasks":
		wantLists, wantTasks = true, true
	case "lists":
		wantLists, wantTasks = true, false
	default:
		wantLists, wantTasks = false, false
	}

	// 1) board (scoped to user's workspace membership)
	var boardID, boardName string
	var err error
	if qid != "" {
		err = db.QueryRow(`
            SELECT b.id, b.name
            FROM boards b
            JOIN workspace_members m ON m.workspace_id = b.workspace_id
            WHERE m.user_id = $1 AND b.id = $2
        `, sess.UserID, qid).Scan(&boardID, &boardName)
		if err == sql.ErrNoRows {
			http.Error(w, "board not found", http.StatusNotFound)
			return
		} else if err != nil {
			http.Error(w, "board query failed", http.StatusInternalServerError)
			return
		}
	} else {
		err = db.QueryRow(`
            SELECT b.id, b.name
            FROM boards b
            JOIN workspace_members m ON m.workspace_id = b.workspace_id
            WHERE m.user_id = $1
            ORDER BY b.created_at ASC
            LIMIT 1
        `, sess.UserID).Scan(&boardID, &boardName)
		if err == sql.ErrNoRows {
			http.Error(w, "no board found", http.StatusNotFound)
			return
		} else if err != nil {
			http.Error(w, "board query failed", http.StatusInternalServerError)
			return
		}
	}

	// 2) lists
	lists := make([]ListDTO, 0)
	if wantLists {
		rows, err := db.Query(`SELECT id, name, position FROM lists WHERE board_id=$1 ORDER BY position ASC`, boardID)
		if err != nil {
			http.Error(w, "lists query failed", http.StatusInternalServerError)
			return
		}
		defer rows.Close()

		for rows.Next() {
			var l ListDTO
			if err := rows.Scan(&l.ID, &l.Name, &l.Position); err == nil {
				l.Tasks = make([]TaskDTO, 0) // non-nil slice
				lists = append(lists, l)
			}
		}
	}

	// 3) tasks per list
	if wantTasks {
		for i := range lists {
			trows, err := db.Query(`SELECT id, title, status, position FROM tasks WHERE list_id=$1 ORDER BY position ASC`, lists[i].ID)
			if err != nil {
				http.Error(w, "tasks query failed", http.StatusInternalServerError)
				return
			}
			tasks := make([]TaskDTO, 0)
			for trows.Next() {
				var t TaskDTO
				if err := trows.Scan(&t.ID, &t.Title, &t.Status, &t.Position); err == nil {
					// assignees
					arows, _ := db.Query(`SELECT user_id FROM task_assignees WHERE task_id=$1`, t.ID)
					aids := make([]string, 0)
					for arows.Next() {
						var uid string
						if err := arows.Scan(&uid); err == nil {
							aids = append(aids, uid)
						}
					}
					arows.Close()
					t.Assignees = aids

					// comment count
					_ = db.QueryRow(`SELECT COUNT(*) FROM comments WHERE task_id=$1`, t.ID).Scan(&t.CommentCount)

					tasks = append(tasks, t)
				}
			}
			trows.Close()
			lists[i].Tasks = tasks
		}
	}

	// 4) respond
	payload := BoardDTO{ID: boardID, Name: boardName, Lists: lists}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(payload)
}


===== END FILE =====


===== BEGIN FILE: server\cmd\api\handlers_comments.go =====

package main

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"strings"
	"time"
)

// ---- DTOs ----
type createCommentReq struct {
	TaskID string `json:"task_id"`
	Body   string `json:"body"`
}
type commentResp struct {
	ID        string    `json:"id"`
	TaskID    string    `json:"task_id"`
	AuthorID  string    `json:"author_id"`
	Body      string    `json:"body"`
	CreatedAt time.Time `json:"created_at"`
}
type commentItem struct {
	ID        string    `json:"id"`
	TaskID    string    `json:"task_id"`
	AuthorID  string    `json:"author_id"`
	Body      string    `json:"body"`
	CreatedAt time.Time `json:"created_at"`
}

// ---- POST /api/comments (auth + CSRF) ----
func createCommentHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	sess, ok := requireAuthAndCSRF(w, r)
	if !ok {
		return
	}

	var req createCommentReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil || req.TaskID == "" || strings.TrimSpace(req.Body) == "" {
		http.Error(w, "bad json", http.StatusBadRequest)
		return
	}

	var id string
	var created time.Time
	if err := db.QueryRow(
		`INSERT INTO comments (task_id, author_id, body) VALUES ($1,$2,$3) RETURNING id, created_at`,
		req.TaskID, sess.UserID, req.Body,
	).Scan(&id, &created); err != nil {
		http.Error(w, "insert failed", http.StatusBadRequest)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(commentResp{
		ID: id, TaskID: req.TaskID, AuthorID: sess.UserID, Body: req.Body, CreatedAt: created,
	})
}

// ---- GET /api/comments?task_id=... (public) ----
func listCommentsHandler(w http.ResponseWriter, r *http.Request, db *sql.DB) {
	if r.Method != http.MethodGet {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	taskID := r.URL.Query().Get("task_id")
	if taskID == "" {
		http.Error(w, "missing task_id", http.StatusBadRequest)
		return
	}
	rows, err := db.Query(`
		SELECT id, task_id, author_id, body, created_at
		FROM comments
		WHERE task_id = $1
		ORDER BY created_at ASC
	`, taskID)
	if err != nil {
		http.Error(w, "query failed", http.StatusInternalServerError)
		return
	}
	defer rows.Close()

	items := make([]commentItem, 0)
	for rows.Next() {
		var c commentItem
		if err := rows.Scan(&c.ID, &c.TaskID, &c.AuthorID, &c.Body, &c.CreatedAt); err == nil {
			items = append(items, c)
		}
	}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(items)
}


===== END FILE =====


===== BEGIN FILE: server\cmd\api\main.go =====

package main

import (
	"database/sql"
	"log"
	"net/http"
	"os"

	_ "github.com/jackc/pgx/v5/stdlib"
)

func main() {
	dsn := os.Getenv("DB_DSN")
	if dsn == "" {
		log.Fatal("DB_DSN not set")
	}

	db, err := sql.Open("pgx", dsn)
	if err != nil {
		log.Fatal("cannot open db:", err)
	}
	defer db.Close()

	if err := db.Ping(); err != nil {
		log.Fatal("cannot ping db:", err)
	}
	log.Println("DB OK")

	var version string
	if err := db.QueryRow("select version()").Scan(&version); err != nil {
		log.Fatal("db query failed:", err)
	}
	log.Println("DB version:", version)

	registerRoutes(db)

	log.Println("API listening on :8080 (with DB)")
	log.Fatal(http.ListenAndServe(":8080", nil))

}


===== END FILE =====


===== BEGIN FILE: server\cmd\api\routes.go =====

package main

import (
	"database/sql"
	"net/http"
)

func registerRoutes(db *sql.DB) {
	http.HandleFunc("/api/boards", func(w http.ResponseWriter, r *http.Request) {
		boardsHandler(w, r, db)
	})
	http.HandleFunc("/api/register", func(w http.ResponseWriter, r *http.Request) {
		registerHandler(w, r, db)
	})
	http.HandleFunc("/api/login", func(w http.ResponseWriter, r *http.Request) {
		loginHandler(w, r, db)
	})
	http.HandleFunc("/api/me", func(w http.ResponseWriter, r *http.Request) {
		meHandler(w, r, db)
	})
	http.HandleFunc("/api/comments", func(w http.ResponseWriter, r *http.Request) {
		switch r.Method {
		case http.MethodGet:
			listCommentsHandler(w, r, db)
		case http.MethodPost:
			createCommentHandler(w, r, db)
		default:
			http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		}
	})
}


===== END FILE =====


===== BEGIN FILE: server\Dockerfile =====

# syntax=docker/dockerfile:1
FROM golang:1.25

# Install Air for hot reload
RUN go install github.com/air-verse/air@latest

WORKDIR /app


===== END FILE =====


===== BEGIN FILE: server\go.mod =====

module github.com/ri5pekt/task-manager/server

go 1.25.1

require (
	github.com/jackc/pgx/v5 v5.7.6
	golang.org/x/crypto v0.37.0
)

require (
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect
	github.com/jackc/puddle/v2 v2.2.2 // indirect
	golang.org/x/sync v0.13.0 // indirect
	golang.org/x/sys v0.32.0 // indirect
	golang.org/x/text v0.24.0 // indirect
)


===== END FILE =====


===== BEGIN FILE: web\.gitignore =====

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files

.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
.pnpm-store/
.vscode/


# Dev artifacts
cookies.txt
server/tmp/
project_snapshot_*.txt

# Tailwind v4 (using @tailwindcss/vite, no PostCSS config)
web/postcss.config.js

===== END FILE =====


===== BEGIN FILE: web\Dockerfile =====

# syntax=docker/dockerfile:1
# Placeholder for Vue app image. We�ll add build steps later.
FROM node:20 AS dev
WORKDIR /app
# (deps, dev server, and prod build will be added later)


===== END FILE =====


===== BEGIN FILE: web\index.html =====

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + Vue</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>


===== END FILE =====


===== BEGIN FILE: web\package.json =====

{
  "name": "web",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@headlessui/vue": "^1.7.23",
    "@heroicons/vue": "^2.2.0",
    "pinia": "^3.0.3",
    "vue": "^3.5.18",
    "vue-router": "^4.5.1",
    "vuedraggable": "^4"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4.1.13",
    "@tailwindcss/vite": "^4.1.13",
    "@vitejs/plugin-vue": "^6.0.1",
    "autoprefixer": "^10.4.21",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.13",
    "vite": "^7.1.2"
  }
}


===== END FILE =====


===== BEGIN FILE: web\public\vite.svg =====

<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

===== END FILE =====


===== BEGIN FILE: web\README.md =====

# Vue 3 + Vite

This template should help get you started developing with Vue 3 in Vite. The template uses Vue 3 `<script setup>` SFCs, check out the [script setup docs](https://v3.vuejs.org/api/sfc-script-setup.html#sfc-script-setup) to learn more.

Learn more about IDE Support for Vue in the [Vue Docs Scaling up Guide](https://vuejs.org/guide/scaling-up/tooling.html#ide-support).


===== END FILE =====


===== BEGIN FILE: web\src\App.vue =====

<template>
    <div class="min-h-screen bg-gray-50 text-gray-900">
        <header class="bg-gray-900 text-white">
            <nav class="mx-auto max-w-5xl px-4 py-3 flex items-center justify-between">
                <RouterLink to="/" class="font-semibold tracking-wide">Task Manager</RouterLink>
                <div class="flex gap-4">
                    <RouterLink to="/" class="hover:text-emerald-300">Home</RouterLink>
                    <RouterLink to="/board" class="hover:text-emerald-300">Board</RouterLink>
                    <RouterLink to="/login" class="hover:text-emerald-300">Login</RouterLink>
                </div>
            </nav>
        </header>

        <main class="mx-auto max-w-5xl px-4 py-6">
            <RouterView />
        </main>
    </div>
</template>

<script setup></script>

<style scoped></style>


===== END FILE =====


===== BEGIN FILE: web\src\assets\vue.svg =====

<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="37.07" height="36" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 198"><path fill="#41B883" d="M204.8 0H256L128 220.8L0 0h97.92L128 51.2L157.44 0h47.36Z"></path><path fill="#41B883" d="m0 0l128 220.8L256 0h-51.2L128 132.48L50.56 0H0Z"></path><path fill="#35495E" d="M50.56 0L128 133.12L204.8 0h-47.36L128 51.2L97.92 0H50.56Z"></path></svg>

===== END FILE =====


===== BEGIN FILE: web\src\components\HelloWorld.vue =====

<script setup>
import { ref } from 'vue'

defineProps({
  msg: String,
})

const count = ref(0)
</script>

<template>
  <h1>{{ msg }}</h1>

  <div class="card">
    <button type="button" @click="count++">count is {{ count }}</button>
    <p>
      Edit
      <code>components/HelloWorld.vue</code> to test HMR
    </p>
  </div>

  <p>
    Check out
    <a href="https://vuejs.org/guide/quick-start.html#local" target="_blank"
      >create-vue</a
    >, the official Vue + Vite starter
  </p>
  <p>
    Learn more about IDE Support for Vue in the
    <a
      href="https://vuejs.org/guide/scaling-up/tooling.html#ide-support"
      target="_blank"
      >Vue Docs Scaling up Guide</a
    >.
  </p>
  <p class="read-the-docs">Click on the Vite and Vue logos to learn more</p>
</template>

<style scoped>
.read-the-docs {
  color: #888;
}
</style>


===== END FILE =====


===== BEGIN FILE: web\src\lib\api.js =====

// web/src/lib/api.js
function getCookie(name) {
    return (
        document.cookie
            .split("; ")
            .find((row) => row.startsWith(name + "="))
            ?.split("=")[1] ?? ""
    );
}

async function request(path, { method = "GET", headers = {}, body } = {}) {
    const isMutation = !["GET", "HEAD"].includes(method.toUpperCase());
    const finalHeaders = new Headers(headers);
    finalHeaders.set("Accept", "application/json");

    // JSON body for mutations unless caller sets something else
    let payload = body;
    if (isMutation && body && !(body instanceof FormData)) {
        finalHeaders.set("Content-Type", "application/json");
        payload = JSON.stringify(body);
    }

    // CSRF for mutations if present
    if (isMutation) {
        const csrf = getCookie("csrf");
        if (csrf) finalHeaders.set("X-CSRF-Token", csrf);
    }

    const res = await fetch(path, {
        method,
        headers: finalHeaders,
        body: payload,
        credentials: "include", // send cookies (sid/csrf)
    });

    // Try to parse JSON if server says it's JSON
    const ctype = res.headers.get("content-type") || "";
    const looksJson = ctype.toLowerCase().startsWith("application/json");
    const data = looksJson ? await res.json().catch(() => null) : await res.text();

    if (!res.ok) {
        const msg = (data && data.error) || (typeof data === "string" ? data : "") || `HTTP ${res.status}`;
        const err = new Error(msg);
        err.status = res.status;
        err.data = data;
        throw err;
    }
    return data;
}

export const api = {
    get: (path, opts = {}) => request(path, { ...opts, method: "GET" }),
    post: (path, body, opts = {}) => request(path, { ...opts, method: "POST", body }),
    put: (path, body, opts = {}) => request(path, { ...opts, method: "PUT", body }),
    patch: (path, body, opts = {}) => request(path, { ...opts, method: "PATCH", body }),
    del: (path, opts = {}) => request(path, { ...opts, method: "DELETE" }),
};


===== END FILE =====


===== BEGIN FILE: web\src\main.js =====

import { createApp } from "vue";
import { createPinia } from "pinia";
import router from "./router";
import "./style.css";
import App from "./App.vue";
import { api } from "./lib/api";

if (import.meta.env.DEV) {
    // dev convenience: use in browser console:  api.get('/api/boards')
    // eslint-disable-next-line no-undef
    window.api = api;
}

const app = createApp(App);
app.use(createPinia());
app.use(router);
app.mount("#app");


===== END FILE =====


===== BEGIN FILE: web\src\router.js =====

// web/src/router.js
import { createRouter, createWebHistory } from "vue-router";
import Home from "./views/Home.vue";

export default createRouter({
    history: createWebHistory(),
    routes: [
        { path: "/", name: "home", component: Home },
        { path: "/login", name: "login", component: () => import("./views/Login.vue") },
        { path: "/board", name: "board", component: () => import("./views/Board.vue") }, // 👈 new
    ],
});


===== END FILE =====


===== BEGIN FILE: web\src\stores\auth.js =====

import { defineStore } from "pinia";
import { api } from "../lib/api";

export const useAuth = defineStore("auth", {
    state: () => ({ user: null, loading: false, error: "" }),
    getters: { isAuthed: (s) => !!s.user },
    actions: {
        async fetchMe() {
            this.loading = true;
            this.error = "";
            try {
                const me = await api.get("/api/me");
                this.user = me;
                return me;
            } catch (e) {
                if (e?.status === 401) this.user = null;
                else this.error = e?.message || "Failed to load user";
                throw e;
            } finally {
                this.loading = false;
            }
        },
        async login(email, password) {
            this.loading = true;
            this.error = "";
            try {
                await api.post("/api/login", { email, password });
                await this.fetchMe();
            } catch (e) {
                this.error = e?.message || "Login failed";
                throw e;
            } finally {
                this.loading = false;
            }
        },
        clientLogout() {
            this.user = null;
            this.error = "";
        },
    },
});


===== END FILE =====


===== BEGIN FILE: web\src\style.css =====

@import "tailwindcss";


===== END FILE =====


===== BEGIN FILE: web\src\views\Board.vue =====

<template>
    <div class="mx-auto max-w-7xl p-6">
        <div class="mb-4 flex items-center gap-3">
            <h1 class="text-2xl font-semibold">Board</h1>
            <button
                @click="loadBoard"
                :disabled="loading"
                class="rounded-md bg-gray-900 px-3 py-1.5 text-sm font-medium text-white hover:bg-gray-800 disabled:opacity-60"
            >
                {{ loading ? "Loading…" : "Refresh" }}
            </button>
            <div v-if="error" class="rounded-md border border-red-200 bg-red-50 px-3 py-2 text-sm text-red-700">
                <span v-if="error.toLowerCase().includes('unauthorized')">
                    You need to log in to view boards.
                    <RouterLink to="/login" class="underline">Go to Login</RouterLink>
                </span>
                <span v-else>{{ error }}</span>
            </div>
        </div>

        <div v-if="board" class="space-y-2">
            <h2 class="text-lg font-medium text-gray-700">{{ board.name }}</h2>

            <!-- Lists grid -->
            <div class="flex gap-4 overflow-x-auto pb-2">
                <div
                    v-for="l in board.lists"
                    :key="l.id"
                    class="w-72 shrink-0 rounded-lg border border-gray-200 bg-white"
                >
                    <div class="border-b border-gray-200 px-4 py-2">
                        <div class="flex items-center justify-between">
                            <span class="font-medium">{{ l.name }}</span>
                            <span class="text-xs text-gray-500">pos {{ l.position }}</span>
                        </div>
                    </div>

                    <ul class="space-y-2 p-3">
                        <li
                            v-for="t in l.tasks"
                            :key="t.id"
                            class="rounded-md border border-emerald-200 bg-emerald-50 p-3"
                        >
                            <div class="flex items-center justify-between">
                                <span class="font-medium">{{ t.title }}</span>
                                <span class="text-xs uppercase tracking-wide text-gray-600">{{ t.status }}</span>
                            </div>
                            <div class="mt-2 flex items-center gap-3 text-sm text-gray-600">
                                <span>🗨️ {{ t.comment_count }}</span>
                                <span>👤 x{{ t.assignees?.length || 0 }}</span>
                                <span class="ml-auto text-xs text-gray-400">pos {{ t.position }}</span>
                            </div>
                        </li>
                        <li v-if="!l.tasks?.length" class="px-3 py-2 text-sm text-gray-500">No tasks</li>
                    </ul>
                </div>
            </div>
        </div>

        <p v-else class="text-gray-600">No board loaded yet.</p>
    </div>
</template>

<script setup>
import { ref, watchEffect } from "vue";
import { useRoute } from "vue-router";
import { api } from "../lib/api";

const route = useRoute();
const loading = ref(false);
const error = ref("");
const board = ref(null);

// Loads first board by default, or ?id=<uuid> if provided
async function loadBoard() {
    loading.value = true;
    error.value = "";
    try {
        const id = route.query.id;
        const url = id ? `/api/boards?id=${encodeURIComponent(id)}` : "/api/boards";
        board.value = await api.get(url);
    } catch (e) {
        error.value = e?.message || "Failed to load board";
    } finally {
        loading.value = false;
    }
}

// auto-load when the view mounts and when ?id changes
watchEffect(() => {
    route.query.id; // track dependency
    loadBoard();
});
</script>

<style scoped></style>


===== END FILE =====


===== BEGIN FILE: web\src\views\Home.vue =====

<template>
    <div class="p-6">
        <h1 class="mb-2 text-xl font-semibold">Home</h1>
        <p v-if="auth.isAuthed">
            Logged in as <strong>{{ auth.user.email }}</strong>
        </p>
        <p v-else>Not logged in.</p>
    </div>
</template>

<script setup>
import { useAuth } from "../stores/auth";
const auth = useAuth();
</script>

<style scoped></style>


===== END FILE =====


===== BEGIN FILE: web\src\views\Login.vue =====

<template>
    <div class="mx-auto max-w-sm py-10">
        <h1 class="mb-6 text-2xl font-semibold">Login</h1>

        <form @submit.prevent="onSubmit" class="space-y-4">
            <div>
                <label class="mb-1 block text-sm font-medium">Email</label>
                <input
                    v-model.trim="email"
                    type="email"
                    required
                    class="w-full rounded-md border border-gray-300 bg-white px-3 py-2 outline-none focus:ring-2 focus:ring-emerald-400"
                    placeholder="you@example.com"
                />
            </div>

            <div>
                <label class="mb-1 block text-sm font-medium">Password</label>
                <input
                    v-model="password"
                    type="password"
                    required
                    class="w-full rounded-md border border-gray-300 bg-white px-3 py-2 outline-none focus:ring-2 focus:ring-emerald-400"
                    placeholder="••••••••"
                />
            </div>

            <button
                type="submit"
                :disabled="auth.loading"
                class="w-full rounded-md bg-gray-900 px-4 py-2 font-medium text-white hover:bg-gray-800 disabled:opacity-60"
            >
                <span v-if="auth.loading">Signing in…</span>
                <span v-else>Sign in</span>
            </button>

            <p v-if="auth.error" class="text-sm text-red-600">{{ auth.error }}</p>
        </form>

        <p class="mt-6 text-sm text-gray-600">Use the account you registered via console.</p>
    </div>
</template>

<script setup>
import { ref } from "vue";
import { useRouter } from "vue-router";
import { useAuth } from "../stores/auth";

const email = ref("");
const password = ref("");
const auth = useAuth();
const router = useRouter();

async function onSubmit() {
    try {
        await auth.login(email.value, password.value);
        router.push("/");
    } catch {
        /* error shown by store */
    }
}
</script>

<style scoped></style>


===== END FILE =====


===== BEGIN FILE: web\vite.config.js =====

import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";
import tailwindcss from "@tailwindcss/vite";

export default defineConfig({
    plugins: [vue(), tailwindcss()],
    server: {
        host: true,
        port: 5173,
        strictPort: true,
        hmr: {
            host: "localhost",
            clientPort: 5173,
            protocol: "ws",
        },
        watch: {
            usePolling: true,
            interval: 300,
        },
        // ⬇️ put the proxy back so /api/* goes to the Go service
        proxy: {
            "/api": { target: "http://api:8080", changeOrigin: true },
        },
    },
});


===== END FILE =====

